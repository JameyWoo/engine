                                                                                                                                                         POJ 1979 red and black    Description  There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.  Write a program to count the number of black tiles which he can reach by repeating the moves described above.  Input  The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.  There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.  '.' - a black tile  '#' - a red tile  '@' - a man on a black tile(appears exactly once in a data set)       1     2     3  The end of the input is indicated by a line consisting of two zeros.  Output  For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).  Sample Input  6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 11 6 ..#..#..#.. ..#..#..#.. ..#..#..### ..#..#..#@. ..#..#..#.. ..#..#..#.. 7 7 ..#.#.. ..#.#.. ###.### ...@... ###.### ..#.#.. ..#.#.. 0 0 Sample Output  45 59 6 13  出现过一个令我费解的错误, 程序运行过程中总是出错误  调试之后发现, 因为没有给走过的点特判一下, 导致走来走去结束不了  题目原文因为markdown 原题出现的 # 会把后面的字作为标题, 所以不得不用代码块来引用  AC代码:  #include &lt;iostream&gt;  using namespace std;  void search(char map[][21], int x, int y, int m, int n, bool ma[][21]) {     if(x == 0 || y == 0 || x &gt; m || y &gt; n || map[x][y] == '#' || ma[x][y]) {         return;     } else {         ma[x][y] = 1;         search(map, x-1, y, m, n, ma);         search(map, x+1, y, m, n, ma);         search(map, x, y-1, m, n, ma);         search(map, x, y+1, m, n, ma);     } }  void loop(int m, int n) {     char map[21][21] = {};     bool ma[21][21] = {};     int x = 0, y = 0, ans = 0;     for( int i = 1; i &lt;= m; ++i ) {         for( int j = 1; j &lt;= n; ++j ) {             cin &gt;&gt; map[i][j];             if(map[i][j] == '@') {                 x = i;                 y = j;             }         }     }     search(map, x, y, m, n, ma);     for( int i = 0; i &lt;= 20; ++i ) {         for( int j = 0; j &lt;= 20; ++j ) {             if( ma[i][j] ) ans++;         }     }     cout &lt;&lt; ans &lt;&lt; endl; }  int main() {     int m, n;     while( cin &gt;&gt; m &gt;&gt; n &amp;&amp; m ) {         loop(n, m);     } }                                            