                                                                                                                                                         CCF 201604-3 路径解析 传送门  没看懂题目, 感觉乱七八糟的, 这是什么规则, 怎么看不懂啊? 无奈之下搜了搜题解, 自己按照大佬的方法做了一次, 觉得好像真是那么回事. 大概是因为没有路径查询的相关经验吧, 所以看题的时候会无法理解一些反常识的操作. 会觉得莫名其妙.  总之, 方法就是如果查询的路径是相对路径, 那么把它添加到当前目录里面去, 绝对路径不变.  然后对新的路径进行正规化处理, 以有一个或多个/作为分隔符, 遇到.就直接跳过去, 这里不太好理解, 这样的话这个.有什么用? 遇到..就把最后一个元素删除, 嗯, 就是类似栈的操作. 其余的都加入到栈中.  要注意的是可能会读取空字符查询, 而普通的cin是会忽略的, 所以用getline来读取一行. 代码中非常巧妙地用了stringstream来处理, 十分值得借鉴学习.  代码只有三十多行, 理解了题目意思就很简单了, 如果理解不了(比如我), 就会一头雾水. 话说这是我的锅还是CCF的锅?  #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; using namespace std;  int main() {     int n;     cin &gt;&gt; n;     string path, s, str;     cin &gt;&gt; path;     cin.get();  // 用getline时千万要注意吸收这个换行符     for (int i = 0; i &lt; n; ++i) {         getline(cin, str);         if (str == "") str = path;         if (str[0] != '/') str = path + '/' + str;         for (int j = 0; j &lt; str.size(); ++j) {             if (str[j] == '/') str[j] = ' ';         }         vector&lt;string&gt; sta;         stringstream ss(str);         while (ss &gt;&gt; s) {             if (s == ".") continue;             else if (s == ".." &amp;&amp; !sta.empty()) sta.pop_back();             else if (s != "..") sta.push_back(s);         }         cout &lt;&lt; '/';         for (int j = 0; j &lt; sta.size(); ++j) {             if (j) cout &lt;&lt; '/';             cout &lt;&lt; sta[j];         }         cout &lt;&lt; endl;     } }  对了, 用getline注意吸收前面的换行符.                                            