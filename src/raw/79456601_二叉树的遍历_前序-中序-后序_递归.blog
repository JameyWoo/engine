                                                                                                                                                          前序遍历( Preorder Tree Walk). 按照根节点, 左子树, 右子树顺序给出节点编号. 中序遍历( Inorder Tree Walk). 按照左子树, 根节点, 右子树顺序给出结点编号 后序遍历( Postorder Tree Walk). 按照左子树, 右子树, 根节点顺序给出结点编号   这三种遍历方法十分接近, 思路上, 使用递归表达, 每个递归函数做好当前的工作就好了, 更小的工作交给下一层递归来实现.  同时, 也可以用堆栈的方式进行遍历, 实现起来较为复杂, 但思路是基本一致的.  使用递归地方法实现时, 三种遍历方法基本只要改动代码顺序即可.  #include &lt;bits/stdc++.h&gt; using namespace std; #define MAX 10005 #define NIL -1  struct Node { int p, l, r; };  Node T[MAX]; int n, root;  void preOrder(int u)  //前序遍历  {     if(u == NIL) return;     cout &lt;&lt; u &lt;&lt; ' ';     preOrder(T[u].l);     preOrder(T[u].r); }  void inOrder(int u) //中序遍历  {     if(u == NIL) return;     inOrder(T[u].l);     cout &lt;&lt; u &lt;&lt; ' ';     inOrder(T[u].r); }  void postOrder(int u)  //后序遍历 {     if(u == NIL) return;     postOrder(T[u].l);     postOrder(T[u].r);     cout &lt;&lt; u &lt;&lt; ' '; }   void buildTree()  //构建一棵树 {     int k, l, r;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i)         T[i].l = T[i].r = NIL;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;         T[k].l = l, T[k].r = r;         if(l != NIL) T[l].p = k;         if(r != NIL) T[r].p = k;     }     for(int i = 0; i &lt; n; ++i)          if(T[i].p == NIL) root = i; }  int main() {     buildTree();     cout &lt;&lt; "preOrder: \n";     preOrder(root);     cout &lt;&lt; endl;     cout &lt;&lt; "inOrder: \n";     inOrder(root);     cout &lt;&lt; endl;     cout &lt;&lt; "postOrder: \n";     postOrder(root);     cout &lt;&lt; endl; }  数据输入:     9    0 1 4    1 2 3    2 -1 -1    3 -1 -1    4 5 8    5 6 7    6 -1 -1    7 -1 -1    8 -1 -1   数据输出:     preOrder:    0 1 2 3 4 5 6 7 8    inOrder:    2 1 3 0 6 5 7 4 8    postOrder:    2 3 1 6 7 5 8 4 0   有一个性质值得注意:     给出任意二叉树中序遍历结点编号, 以及前序或后序中任一结果, 可确定唯一的二叉树    因为:    前序 = 根节点 + 左子树 + 右子树    中序 = 左子树 + 根节点 + 右子树    后序 = 左子树 + 右子树 + 根节点                                             