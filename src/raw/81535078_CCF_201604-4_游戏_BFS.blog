                                                                                                                                                         CCF 201604-4 游戏 传送门  一看题目觉得很简单, 这不就是一道bfs水题吗? 但心里面告诉自己千万不要轻敌, 认真分析下题目先.  如果按照常规的BFS思路, 会有一个bug: 因为这些障碍是在一段时间不通过,所以如果回来可能会更快. 那么这时vis数组就失效了,因为回不来…  思考一下会发现, 不外乎两种情况.  一种是不会回来了, 刚好可以过掉  另一种是回来反而会得到更优的解, 这种情况下设置vis数组就是bug了.  怎么办呢? 取消vis吗? 可这样一来, 程序一定会超时, 事实上只得了20分.  有一种可行的办法: 既然回来可能会更加快, 那么保留vis数组, 但是把那种情况添加进去作为一种情况考虑. 而回来这个过程, 最短时间是+2, 因为+4, +6, +8没有意义.  然后提交了程序, 得了70分. 思路应该是没错的, 但是应该是哪里有个小bug(值30分呢). 仔细检查后发现, 因为最后添加的一种情况每次时间+2, 所以有可能在队列中它提前到了终点, 而此时它的时间其实还没有队列后面的那些点到的快. 也就是说, 它不是最优解. 那么难道现在对所有到终点的时间做一个筛选, 找出最小的吗? 有点太麻烦了.  我们直击本质, 之所以会提前结束, 是因为它到了不属于他的位置, 如果时间长的点能够自觉一点到后面去, 那结果会是对的. so, 如何让它自觉? 优先队列!  用优先队列的代码一改, 100分.  百度了下其他博主的代码: 看到有的博主是开了三维数组, 把时间也当作一个行走维度. 这样的话就不用像我那样考虑那些了(我的方法容易疏忽一些东西), 而是直接三维bfs, 转化成常规模型. 大佬博客链接 , 这种思路很有启发, 增加维度.  同时, 这也给了我一个启发: 我们用普通队列模拟BFS时其实不是真正的BFS, 优先队列才是. 而在一般情况下他们没什么不同(此题就不是一般情况), 普通队列反而更快, 所以我们省事省时就直接用队列了. 我们用普通队列多了, 反而就忽略了BFS找到最短路长的本质, 结果出了错才想到优先队列, 岂不怪哉? 所以, 以后BFS先判断是否应该用优先队列, 切勿忽略本质  因为和一个同学的讨论，让我发现了之前程序的一个bug。下面的完整代码都是更新了的，先展示修改了的部分（BFS函数有一些小调整）。  原BFS函数  long long BFS() {     priority_queue&lt;Time&gt; Q;     Q.push(Time(1, 1, 0));     vis[1][1] = 1;     while (1) {         long long x = Q.top().x, y = Q.top().y, time = Q.top().time;         if (x == n &amp;&amp; y == m) return time;         Q.pop();         for (long long i = 0; i &lt; 4; ++i) {             long long xx = x + move[i][0], yy = y + move[i][1];             if (xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;             if (time + 1 &gt;= map[xx][yy].left &amp;&amp; time + 1 &lt;= map[xx][yy].right) continue;             if (vis[xx][yy]) continue;             vis[xx][yy] = true;             Q.push(Time(xx, yy, time + 1));         }         Q.push(Time(x, y, time + 2));     } }  现在的BFS函数    long long BFS() {     priority_queue&lt;Time&gt; Q;     Q.push(Time(1, 1, 0));     vis[1][1] = 1;     while (1) {         long long x = Q.top().x, y = Q.top().y, time = Q.top().time;         if (x == n &amp;&amp; y == m) return time;         Q.pop();         Q.push(Time(x, y, time + 2));         if (time &gt;= map[x][y].left &amp;&amp; time &lt;= map[x][y].right) continue;         for (long long i = 0; i &lt; 4; ++i) {             long long xx = x + move[i][0], yy = y + move[i][1];             if (xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;             if (time + 1 &gt;= map[xx][yy].left &amp;&amp; time + 1 &lt;= map[xx][yy].right) continue;             if (vis[xx][yy]) continue;             vis[xx][yy] = true;             Q.push(Time(xx, yy, time + 1));         }     } }  完整更新bug代码：  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std;  struct Node {     long long left, right;     Node () { left = right = 0x3f3f3f3f; } };  struct Time {     long long x, y, time;     Time(long long x, long long y, long long t) : x(x), y(y), time(t) {}     friend bool operator &lt; (Time A, Time B) {         return A.time &gt; B.time;     } };  long long n, m, t, vis[105][105] = {}; long long move[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; Node map[105][105];  long long BFS() {     priority_queue&lt;Time&gt; Q;     Q.push(Time(1, 1, 0));     vis[1][1] = 1;     while (1) {         long long x = Q.top().x, y = Q.top().y, time = Q.top().time;         if (x == n &amp;&amp; y == m) return time;         Q.pop();         Q.push(Time(x, y, time + 2));         if (time &gt;= map[x][y].left &amp;&amp; time &lt;= map[x][y].right) continue;         for (long long i = 0; i &lt; 4; ++i) {             long long xx = x + move[i][0], yy = y + move[i][1];             if (xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;             if (time + 1 &gt;= map[xx][yy].left &amp;&amp; time + 1 &lt;= map[xx][yy].right) continue;             if (vis[xx][yy]) continue;             vis[xx][yy] = true;             Q.push(Time(xx, yy, time + 1));         }     } }  int main() {     cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;     for (long long i = 0, u, v, l, r; i &lt; t; ++i) {         cin &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r;         map[u][v].left = l;         map[u][v].right = r;     }     long long ans = BFS();     cout &lt;&lt; ans; }  三维代码：    #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std;  struct Node {     int x, y, t;     Node (int x, int y, int t) : x(x), y(y), t(t) {} };  const int maxn = 105; int n, m, t; int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; bool vis[maxn][maxn][maxn*3] = {}; // 真坑，就是这个数组开小了，应该开3倍。为啥？因为加入每走一步             // 堵一次（最坏情况），那么最多就是三倍。  int main() {     cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;     for (int i = 0; i &lt; t; ++i) {         int x, y, ts, te;         cin &gt;&gt; x &gt;&gt; y &gt;&gt; ts &gt;&gt; te;         for (int j = ts; j &lt;= te; ++j) {             vis[x][y][j] = true;         }     }     queue&lt;Node&gt; Q;     Q.push(Node(1, 1, 0));     vis[1][1][0] = true;     while (!Q.empty()) {         int x = Q.front().x, y = Q.front().y, t = Q.front().t;         Q.pop();         if (x == n &amp;&amp; y == m) {             cout &lt;&lt; t;             return 0;         }         ++t;         for (int i = 0; i &lt; 4; ++i) {             int xx = x + move[i][0], yy = y + move[i][1];             if (xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;             if (vis[xx][yy][t]) continue;             Q.push(Node(xx, yy, t));             vis[xx][yy][t] = true;         }     } }                                            