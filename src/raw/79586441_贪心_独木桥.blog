                                                                                                                                                         独木桥  这是一道贪心题, 刚开始死活贪不出, 没有明确的思路.  对于这么多士兵行走, 难道每个士兵都去考虑, 然后还模拟士兵和士兵相撞产生的各种情况?  问题的本质: 士兵相遇后, 原路返回, 但其实和士兵直走擦肩而过没有区别.   所以思路很明确了:      最小时间为所有士兵最小时间的最大值    最大时间为所有士兵最大时间的最大值   第二版代码是这样的:    #include &lt;iostream&gt; using namespace std;  int main() {     int l, n, tmp, ans1 = 0, ans2 = 0;      cin &gt;&gt; l &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; tmp;         ans1 = max(tmp &gt; l/2 ? (l + 1 - tmp) : tmp, ans1);         ans2 = max(ans2, tmp &gt; l/2 ? tmp : l + 1 - tmp);     }     cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2; }   然而后来了解到那个思路后, 发现这样最精确    #include &lt;iostream&gt; using namespace std;  int main() {     int l, n, maxv = 0, minv = 0, x;     cin &gt;&gt; l &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         minv = max(minv, min(x, l + 1 - x));         maxv = max(maxv, max(x, l + 1 - x));     }     cout &lt;&lt; minv &lt;&lt; ' ' &lt;&lt;  maxv; }  这是一道好题. 透过现象看本质.                                            