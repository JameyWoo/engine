                                                                                                                                                         选题三 仿照选题一中的代码，定义一个整型数/短整型数组，应该如何实现？对如下代码你预估的执行结果是什么？ 实际GCC 中执行结果是什么？请解析。 #include &lt;stdio.h&gt;  int main() {     char a[6]={'H','N','U','e','r','\0'};     char b[6]={72,78,85,101,114,0};     int c[2]={(72&lt;&lt;24)+(78&lt;&lt;16)+(85&lt;&lt;8)+101,114&lt;&lt;24};     printf("%d,%d\n", sizeof(char),sizeof(int));     printf("%s\n",a);     printf("%s\n",b);     printf("%s\n",c);     return 0; }  使用（短）整型 #include &lt;stdio.h&gt;  int main() {     float a[3]={1143139122437582505939828736.0,76482007234779498639230238720.0,9.222452464e-39};     int b[3] = {1819043144,1870078063,6581362};     short c[6] = {25928,27756,8303,28535,27762,100};     printf("%d\n", sizeof(float));     printf("%s\n",a);     printf("%s\n",b);     printf("%s\n",c);     return 0; }  输出结果： 4 Hello world Hello world Hello world  预估与实际 预估输出： 1,4 HNUer HNUer HNUer  实际输出 1,4 HNUer HNUer eUNH  初始分析 根据对代码一的粗略了解，知道了用%s格式输出数组，将按照读取字符串的方式，每次读取一个char长度即1字节的长度。因此要分析输出结果，需要求出对应的c数组的二进制位。 将这些数转化成对应的char类型 (72&lt;&lt;24)+(78&lt;&lt;16)+(85&lt;&lt;8)+101 // 第一个数 1213093221 // 转化为十进制数位 0100 1000 0100 1110 0101 0101 0110 0101 // 转化为二进制数 114&lt;&lt;24 // 第二个数 1912602624 // 转化为十进制数位 0111 0010 0000 0000 0000 0000 0000 0000 // 转化为二进制数 然后逐一分析每个Byte。 分析结果是这样的 0100 1000 0100 1110 0101 0101 0110 0101 0100 1000   the decimalism is   72, the char is H 0100 1110   the decimalism is   78, the char is N 0101 0101   the decimalism is   85, the char is U 0110 0101   the decimalism is   101, the char is e  0111 0010 0000 0000 0000 0000 0000 0000 0111 0010   the decimalism is   114, the char is r 0000 0000   the decimalism is   0, the char is 0000 0000   the decimalism is   0, the char is 0000 0000   the decimalism is   0, the char is  decimalism 的意思是十进制。 也就是说，int数组c如果按位转化为char*字符串，那么输出应该和前面几个一样，为HNUer才是，为什么会反而输出的是eUNH。 解惑 原来，在计算机中，有种叫做字节序的东西。  字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指存储器中或在数字通信链路中，组成多字节的字的字节的排列顺序。   在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。   字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。   例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,…。而小端法将是：0x100: 67, 0x101: 45,…。 —引自维基百科  举个栗子 对于一个类型为int，位于地址0x100处，它的十六进制为0x12345678，地址范围为0x100~0x103字节的变量，它的大端序是这样的： 纵向看  横向看  而小端序是这样的： 纵向看：  横向看：  因此，我以为会输出HNUer，是因为我误把输出字符的顺序当成了从高位先输出。而实际上，在我的计算机上，字符存储的是字节序是小端序。 从低位往高位读的话，它是读出eUNH，遇到第一个’\0’中止。 如下图：  如果是大端序的话 从低位往高位读，刚好就是HNUer。如下图：                                               