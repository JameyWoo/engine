                                                                                                                                                            一. 什么是二叉查找树? 二. 如何建立一棵二叉树? 1. 定义结点的存储方式. 2. 获取数据 3. 构建二叉查找树 4. 插入函数 5. 中序遍历二叉树   三. 删除操作 1. 前驱与后继 如何求得前驱和后继 1) findMax()函数 2) findMin()函数   2. 删除的逻辑理解 3. 完整代码            一. 什么是二叉查找树?  二叉查找树是一种特殊的二叉树, 又称为排序二叉树, 二叉搜索树, 二叉排序树.  递归定义如下:     1. 要么二叉查找树是一棵空树    2.  要么二叉查找树由根结点, 左子树, 右子树组成, 其中左子树, 右子树都是二叉查找树, 且左子树上所有结点的数据域均小于或等于根节点的数据域, 有紫书上所有节点的数据域都大于根节点的数据域.   二叉查找树的性质?      二叉查找树具有二叉树的性质     二叉查找树是有序数, 它的中序遍历结果就是它的结点的增序.   从我之前对二叉树的讨论来看, 上次我之所以觉得无法仅凭一组数据就建立一棵二叉树, 其原因就是那颗二叉树没有定义规则. 学到二叉查找树这里, 之前的疑惑也解开了. 二叉查找树是有规则的, 因此我们可以根据这个规则进行明确的插入操作, 而插入操作的集合, 其实就是建立一棵二叉查找树.    二. 如何建立一棵二叉树?  1. 定义结点的存储方式.  struct Node {     int data;     Node *left, *right;     Node () { left = right = NULL; } };  分别代表数据域, 左孩子结点, 有孩子结点. 建立构造函数, 方便后面操作.    2. 获取数据      int n, x;     cin &gt;&gt; n;     vector&lt;int&gt; v;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         v.push_back(x);     }     /*     7     8 6 5 7 10 8 11     */    3. 构建二叉查找树  ...... Node *root = creatTree(v);  ...... Node* creatTree(vector&lt;int&gt; v) {     Node *root = NULL;     for (int i = 0; i &lt; v.size(); ++i) {         insert(root, v[i]);     }     return root; }  从上面的代码可以发现, 构建二叉查找树的过程其实就是不断插入结点的过程.    4. 插入函数  void insert(Node* &amp;root, int val) {     if (root == NULL) {         root = new Node;         root-&gt;data = val;         return;     }     if (val &lt;= root-&gt;data) insert(root-&gt;left, val);     else insert(root-&gt;right, val); }    5. 中序遍历二叉树  void inOrder(Node *root) {     if (root == NULL) return;     inOrder(root-&gt;left);     cout &lt;&lt; root-&gt;data &lt;&lt; ' ';     inOrder(root-&gt;right); }  至此, 我们的二叉查找树就建立完成了.  值得注意的是, 在insert函数中, 传递root指针时, 一定要使用&amp;引用符号, 不然时无法修改值的.  完整代码如下:    #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int data;     Node *left, *right;     Node () { left = right = NULL; } };  void insert(Node* &amp;root, int val) {     if (root == NULL) {         root = new Node;         root-&gt;data = val;         return;     }     if (val &lt;= root-&gt;data) insert(root-&gt;left, val);     else insert(root-&gt;right, val); }  Node* creatTree(vector&lt;int&gt; v) {     Node *root = NULL;     for (int i = 0; i &lt; v.size(); ++i) {         insert(root, v[i]);     }     return root; }  void inOrder(Node *root) {     if (root == NULL) return;     inOrder(root-&gt;left);     cout &lt;&lt; root-&gt;data &lt;&lt; ' ';     inOrder(root-&gt;right); }  int main() {     int n, x;     cin &gt;&gt; n;     vector&lt;int&gt; v;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         v.push_back(x);     }     Node *root = creatTree(v);      inOrder(root);     cout &lt;&lt; endl; } /*   7 8 6 5 7 10 8 11 */      三. 删除操作  既然二叉查找树有插入的操作, 那么它必然有删除的操作.  删除操作较为复杂, 涉及的知识稍多, 因此单独提出.  我们思考这样一个问题: 倘若我们要删除一个值为val的结点, 如果它有孩子结点的话, 那么必然需要有一个数来取代它的位置, 因为树的非叶子结点不可能为空.  那么我们选哪个数来取代它的位置呢? 有两个可供选择的方案: 前驱与后继  1. 前驱与后继     前驱指的是一个结点的左子树里面的最大权值结点. 后继指的是一个结点的右子树里面的最小权值结点.   这两个结点很特殊, 因为根据二叉查找树的有序性, 只有这两个结点有资格取代那个结点.  如何求得前驱和后继  思考一下会发现, 一个结点的左子树上的结点是比自己小的结点, 右子树上的结点是比自己大的结点, 那么要找到该结点左子树里权值最大的结点, 只需从左子树根节点一直遍历右孩子结点, 直到右孩子结点指向NULL.     1) findMax()函数  Node* findMax(Node *root) {     while (root-&gt;right != NULL) root = root-&gt;right;     return root; }  此函数用来查找左子树权值最大的结点并返回其指针.    2) findMin()函数  Node* findMin(Node *root) {     while (root-&gt;right != NULL) root = root-&gt;right;     return root; }  此函数用来查找右子树权值最小的结点并返回其指针.    2. 删除的逻辑理解  删除操作的逻辑比较复杂. 可以这样解释:        如果根节点为空, 则返回   如果根节点比val更大, 则转到左结点删除   如果根节点比val更小, 则转到右结点删除   如果相同, 那么       1)如果无右子结点, 则找到前驱赋值并删除前驱结点       2)如果无左子结点, 则找到后继赋值并删除后继节点       一个优化: 可以存储父节点, 删除前驱时直接将其左结点接到其父节点的右结点.        3)如果都没有, 则是叶子, 那么直接删除       4)如果都有, 任意选(或者优化:  (以避免树不平衡               &lt; 1 &gt;选择高度更高的              &lt; 2 &gt;2.随机或轮流选择前驱后继      void deleteNode(Node* &amp;root, int val) {     if (root == NULL) return;     if (root-&gt;data &lt; val) deleteNode(root-&gt;right, val);     else if (root-&gt;data &gt; val) deleteNode(root-&gt;left, val);     else {         if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {             root = NULL;         } else if (root-&gt;right == NULL) {             Node* pre = findMax(root-&gt;left);             root-&gt;data = pre-&gt;data;             deleteNode(root-&gt;left, pre-&gt;data); // 为什么不可以直接pre?          } else {             Node* next = findMin(root-&gt;right);             root-&gt;data = next-&gt;data;             deleteNode(root-&gt;right, next-&gt;data);         }     } }  同样注意: 不要忘记加引用符号 &amp;     3. 完整代码  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int data;     Node *left, *right;     Node () { left = right = NULL; } };  void insert(Node* &amp;root, int val) // 一定要加这个引用符号!!!  {     if (root == NULL) {         root = new Node;         root-&gt;left = root-&gt;right = NULL;         root-&gt;data = val;         return;     }     //if (val == root-&gt;data) return;     if (val &gt; root-&gt;data) insert(root-&gt;right, val);     else insert(root-&gt;left, val); }  Node* creatBst(vector&lt;int&gt; v) {     Node *root = NULL;     int len = v.size();     for (int i = 0; i &lt; len; ++i) {         insert(root, v[i]);     }     return root; }  void inOrder(Node *root) {     if (root == NULL) return;     inOrder(root-&gt;left);     cout &lt;&lt; root-&gt;data &lt;&lt; ' ';     inOrder(root-&gt;right); }  Node* findMax(Node *root) {     while (root-&gt;right != NULL) root = root-&gt;right;     return root; }  Node* findMin(Node *root) {     while (root-&gt;left != NULL) root = root-&gt;left;     return root; }  void deleteNode(Node* &amp;root, int val) {     if (root == NULL) return;     if (root-&gt;data &lt; val) deleteNode(root-&gt;right, val);     else if (root-&gt;data &gt; val) deleteNode(root-&gt;left, val);     else {         if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {             root = NULL;         } else if (root-&gt;right == NULL) {             Node* pre = findMax(root-&gt;left);             root-&gt;data = pre-&gt;data;             deleteNode(root-&gt;left, pre-&gt;data); // 为什么不可以直接pre?          } else {             Node* next = findMin(root-&gt;right);             root-&gt;data = next-&gt;data;             deleteNode(root-&gt;right, next-&gt;data);         }     } }  int main() {     int n, x;     vector&lt;int&gt; v;     cin &gt;&gt; n;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         v.push_back(x);     }     Node* root = creatBst(v);     inOrder(root);     cout &lt;&lt; endl;     while (cin &gt;&gt; x) {         deleteNode(root, x);         inOrder(root);         cout &lt;&lt; endl;     } } /* 7 8 6 5 7 10 8 11  7 8 10 11 8 6 7 5 */                                            