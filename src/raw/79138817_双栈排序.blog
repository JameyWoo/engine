                                                                                                                                                         此篇博客要讲的是双栈排序, 即已知一个不规则栈的元素, 利用另一个空栈, 进行排序.  我上一篇博客讨论了只用一个栈进行排序的情况, 因为栈这种数据结构的先入后出的特性, 只用一个栈很有可能无法全部排序, 只能获得字典序最大的排列. 而使用两个栈, 则可以全部排列.  如何利用两个栈排列呢?此处讨论从栈顶到栈底的升序排列(对stack2).  首先从stack1中取出一个元素temp, 然后从顶开始把stack2中小于该元素的元素压入stack1中, 遇到第一个不符合条件的即停止; 用while. 然后把temp压入stack2中, 再把之前压入stack1中的元素压回stack2中. 每次处理一个栈顶元素, 所以每次循环之后, stack的元素都是排列好的, 且为升序. 因此对stack1来说, 是降序(如果把排列好的stack2压入stack1中).  没有使用STL的代码:  #include &lt;iostream&gt; using namespace std;  int main( ) {     int n;     cin &gt;&gt; n;     int *s1 = new int [n];     int *s2 = new int [n];     for( int i = 0; i &lt; n; ++i ) {         cin &gt;&gt; s1[i];     }     int top1 = n-1;     int top2 = -1;     while( top1 &gt;= 0 ) {         int tmp = s1[top1];         top1--;         while(s2[top2] &lt; tmp &amp;&amp; top2 &gt;= 0) {             top1++;             s1[top1] = s2[top2];             top2--;         }         top2++;         s2[top2] = tmp;         while(s1[top1] &lt;= s2[top2] &amp;&amp; top1 &gt;= 0) {             top2++;             s2[top2] = s1[top1];             top1--;         }     }     for( int i = top2; i &gt;= 0; --i ) {         cout &lt;&lt; s2[i] &lt;&lt; ' ';     } }  使用STL的代码  #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std;  int main( ) {     stack &lt;int&gt; s1, s2;     int n, tmp;     cin &gt;&gt; n;     for( int i = 0; i &lt; n; ++i ) {         cin &gt;&gt; tmp;         s1.push(tmp);     }     while( !s1.empty() ) {         int temp = s1.top();         s1.pop();         while( !s2.empty() &amp;&amp; s2.top() &lt; temp ) {             s1.push(s2.top());             s2.pop();         }         s2.push(temp);         while( !s1.empty() &amp;&amp; s1.top() &lt;= s2.top() ) {             s2.push(s1.top());             s1.pop();         }     }     while( !s2.empty() ) {         cout &lt;&lt; s2.top() &lt;&lt; ' ';         s2.pop();     } }                                            