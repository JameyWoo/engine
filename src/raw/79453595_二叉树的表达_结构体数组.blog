                                                                                                                                                         思路是用结构体储存数的一个结点的信息, 其中包括parent, left, right;  因为是二叉树, 所以不必使用左子右兄弟法  同时, 因为本题二叉树的结点数量固定, 因此可以利用结构体数组来实现.  涉及几个操作:     建立一棵二叉树    求二叉树各结点的深度    求二叉树各结点的高度    得到二叉树的信息并输出   其实比上一篇有根树的表达更简单    #include &lt;bits/stdc++.h&gt; using namespace std; #define MAX 10005 #define NIL -1  struct Node  {int p, l, r; };  //结点结构体  Node T[MAX]; int D[MAX], H[MAX], n, root;  //深度, 高度, 结点数量, 根节点  void setDepth(int u, int d)  //递归得到各结点深度 {     if(u == NIL) return;     D[u] = d;     setDepth(T[u].l, d+1);     setDepth(T[u].r, d+1); }  int setHeight(int u)   //递归得到各结点高度 {     int h1 = 0, h2 = 0;     if(T[u].l != NIL) h1 = setHeight(T[u].l) + 1;     if(T[u].r != NIL) h2 = setHeight(T[u].r) + 1;     return H[u] = max(h1, h2); }  void buildTree()  //构建一棵树, 并给出根节点信息 {     int k, l, r;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) T[i].p = NIL;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;         T[k].l = l, T[k].r = r;         if(l != NIL) T[l].p = k;         if(r != NIL) T[r].p = k;     }     for(int i = 0; i &lt; n; ++i)             if(T[i].p == NIL) root = i; }  void print(int u) {     cout &lt;&lt; "node " &lt;&lt; u &lt;&lt; ": parent = " &lt;&lt; T[u].p &lt;&lt; ", sibling = ";     if(T[T[u].p].l != NIL &amp;&amp; T[T[u].p].l != u) cout &lt;&lt; T[T[u].p].l;     else if(T[T[u].p].r != NIL &amp;&amp; T[T[u].p].r != u) cout &lt;&lt; T[T[u].p].r;     else cout &lt;&lt; -1;     int deg = 0;     if(T[u].l != NIL) deg++;     if(T[u].r != NIL) deg++;     cout &lt;&lt; ", degree = " &lt;&lt; deg &lt;&lt; ", depth = " &lt;&lt; D[u] &lt;&lt; ", height = " &lt;&lt; H[u] &lt;&lt; ", ";     if(u == root) cout &lt;&lt; "root";     else if(deg == 0) cout &lt;&lt; "leaf";     else cout &lt;&lt; "internal node";     cout &lt;&lt; endl; }  int main() {     buildTree();     setDepth(root, 0);     setHeight(root);     for(int i = 0; i &lt; n; ++i) print(i); }                                            