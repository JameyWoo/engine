                                                                                                                                                         完全二叉树的逻辑结构是树结构, 但由于其特殊性, 数据结构中常用数组来存储.  访问父节点, 左子结点, 右子节点都很方便     数组存储以1为起点    假设有某一结点u    A[u/2]为其父节点, 当且仅当u&gt;1    A[u* 2]为其左子结点, 当且仅当u*2 &lt;= n    A[u* 2 +1]为其右子节点, 当且仅当u*2+1 &lt;= n   #include &lt;iostream&gt; using namespace std;  int main() {     int n;     cin &gt;&gt; n;     int *q = new int [n+1];     q[0] = -1;     for(int i = 1; i &lt;= n; ++i) {         cin &gt;&gt; q[i];     }     for(int i = 1; i &lt;= n; ++i) {         cout &lt;&lt; "node " &lt;&lt; i &lt;&lt; ':' &lt;&lt; "key:" &lt;&lt; q[i] &lt;&lt; '\n';         cout &lt;&lt; "parent:" &lt;&lt; q[i/2] &lt;&lt; ' ';         if(2*i &lt;= n) cout &lt;&lt; "left son:" &lt;&lt; q[i*2] &lt;&lt; ' ';         if(2*i+1 &lt;= n) cout &lt;&lt; "right son:" &lt;&lt; q[i*2+1];         cout &lt;&lt; endl &lt;&lt; endl;     } } /* 5 7 8 1 2 3 */  二叉堆以完全二叉树的结构表示     最大堆性质: 结点的键值小于等于其父节点的键值    最小堆性质: 结点的键值大于等于其父节点的键值   满足最大堆性质的二叉堆称为最大堆  同理最小堆  下面代码将一个普通数组按最大堆性质更新    /* 建立一个最大堆  */ #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 1&lt;&lt;30 int n;  void getChange(int *dui, int i) {     int l = 2*i, r = l+1, large = i;     if(l &lt;= n &amp;&amp; dui[l] &gt; dui[large]) large = l;     if(r &lt;= n &amp;&amp; dui[r] &gt; dui[large]) large = r;     if(large != i) {         swap(dui[i], dui[large]);         getChange(dui, large);     } }  int main() {     cin &gt;&gt; n;     int *dui = new int [n+1];     for(int i = 1; i &lt;= n; ++i)         cin &gt;&gt; dui[i];        //输入一个混乱的堆     for(int i = n/2; i &gt;= 1; --i)         getChange(dui,i);     for(int i = 1; i &lt;= n; ++i) {         cout &lt;&lt; dui[i] &lt;&lt; ' ';     } } /* 5 7 8 1 2 3 */  以下代码建立一个具有最小堆性质的优先级队列    /* 建立一个最小堆, 获得以小为优先级的优先级队列  */  #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int n;  void getChange(int *p, int i) {     int l = i*2, r = i*2+1, mm = i;     if(l &lt;= n &amp;&amp; p[l] &lt; p[mm]) mm = l;     if(r &lt;= n &amp;&amp; p[r] &lt; p[mm]) mm = r;     if(mm != i) {         swap(p[mm], p[i]);         getChange(p, mm);     } }  int pop(int *p)  {     int m = p[1];     p[1] = p[n--];     getChange(p, 1);     return m; }  int main() {     cin &gt;&gt; n;     int *priQueue = new int [n+1];     for(int i = 1; i &lt;= n; ++i)         cin &gt;&gt; priQueue[i];     for(int i = n/2; i &gt;= 1; --i)         getChange(priQueue, i);     for(int i = 1; i &lt;= n; ++i) {         cout &lt;&lt; priQueue[i] &lt;&lt; ' ';     }     for(int i = n; i &gt;= 1; --i) {         cout &lt;&lt; "\n已弹出!\n";         cout &lt;&lt; "弹出值为:" &lt;&lt; pop(priQueue) &lt;&lt; '\n' &lt;&lt; '\n';     }  } /* 5 7 8 1 2 3 */  下面代码是从无到有建立一个优先级队列, 由插入操作, 弹出优先级最大操作    /* 从无到有地建立最大堆优先队列  */  #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX (1&lt;&lt;16)   int n = 0, que[MAX+1];  void Change(int u) {     int l = u*2, r = u*2+1, large = u;     if(l &lt;= n &amp;&amp; que[large] &lt; que[l]) large = l;     if(r &lt;= n &amp;&amp; que[large] &lt; que[r]) large = r;     if(large != u) {         swap(que[large], que[u]);         Change(large);     } }  int pop() {     int m = que[1];     que[1] = que[n--];     Change(1);     return m; }  void insert(int x) {     que[++n] = x;     int u = n;     while(u &gt; 1 &amp;&amp; que[u/2] &lt; que[u]) {  //向上调整         swap(que[u], que[u/2]);         u /= 2;     } }  int main() {     int x;     string str;     while(1) {         cin &gt;&gt; str;         if(str == "end") break;         if(str == "insert") {             cin &gt;&gt; x;             insert(x);         } else if(str == "extract") {             cout &lt;&lt; "弹出:" &lt;&lt; pop() &lt;&lt; endl &lt;&lt; endl;         }     } } /* insert 8 insert 2 extract insert 10 extract insert 11 extract extract end */                                             