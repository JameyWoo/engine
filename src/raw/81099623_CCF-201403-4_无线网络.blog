                                                                                                                                                            试题编号： 201403-4    试题名称：   无线网络    时间限制：   1.0s    内存限制：   256.0MB    问题描述：    问题描述    　　目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。    　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。    　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?    输入格式    　　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。    　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。    　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。    　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。    输出格式    　　输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。    样例输入    5 3 1 3    0 0    5 5    0 3    0 5    3 5    3 3    4 4    3 0    样例输出    2   这道题是CCF第四题, 通常第四题会是一道图论题, 这题也不例外.  因为博主做的图论题目还是比较少, 所以做到这道不那么常规的图论问题时不知道怎么下手.  为什么说不常规? 因为以前做的图论题都是给出边的信息, 每条边上有两个点, 有可能还有权值. 但是这道题, 只给了点, 以及点可以到达的半径. 没见过, 所以不知道怎么套模型.这是遇到的第一个问题.  后来看其他大佬分享的博客, 知道了这种情况其实是很容易转变成常规的图论模型的. 只要计算点和点之间的距离, 然后根据可达半径判断这两点是否可以成边, 这样就可以以邻接矩阵的形式遍历各边.  so, 第一个问题解决了, 它使得此题回归到常规图论模型.  接下来遇到了第二个问题: 如果可选的k个点都被选出来了, 那么对这确定的n+k个点, 我们怎么得到最小的路径长度呢? 其实还是很容易想到BFS的吧, 因为此前做过的好些走迷宫步数最小问题用bfs很方便的, 一层一层铺开, 每层的中转次数是一样的, 那么第一个到大2点的路径, 就是中转数最小的路径了.  so, 第二个问题也解决了, 它使得我们有方法找到最小中转数  然后是第三个问题: 可选k是不确定的, 怎么办, 难道我们还要遍历出所有可能的组合吗?   虽然我不知道那样为什么是对的, 但我知道那样子就是对的!  不用找出所有可能的情况, 只要在bfs的过程中记录我们使用的点有多少个在那k个点中, 如果刚好是k个, 那么就不能用了, 否则是可以用的.  即, 只要进行一次判断, 选择出循环的上界. 每次push进去一个点, 判断它是不是可选点, 如果是, 可选点数量就+1.   so, 第三个问题也解决了  有很多细节需要注意, 代码可以控制在四十多行.  #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std;  const int maxn = 205; long long n, m, k, r, _max = -1; bool visit[maxn] = {};  struct Statu {     long long x, y, k;     int step;     Statu () { step = k = 0; }     Statu (int x, int y, int s, int k) : x(x), y(y), step(s), k(k) {} } map[maxn];  int bfs(int begin, int end) {     queue&lt;Statu&gt; Q;     Q.push(Statu(map[begin].x, map[begin].y, 0, 0));     visit[begin] = true;     while (!Q.empty()) {         Statu s = Q.front();         Q.pop();         if (s.x == map[end].x &amp;&amp; s.y == map[end].y) return s.step - 1; // 求的是中转个数,步数减一          if (s.k == k) _max = n; // step, k搞混!!!          else _max = n + m;         for (int i = 1; i &lt;= _max; ++i) {             if (visit[i]) continue;             if ((map[i].x - s.x)*(map[i].x - s.x) + (map[i].y - s.y)*(map[i].y - s.y) &gt; r*r) continue;             visit[i] = true;              Q.push(Statu(map[i].x, map[i].y, s.step + 1, i &gt; n ? s.k + 1 : s.k)); // 错写成m          }     } }  int main() {     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r;     for (int i = 1; i &lt;= n + m; ++i) {         cin &gt;&gt; map[i].x &gt;&gt; map[i].y;     }     int ans = bfs(1, 2);     cout &lt;&lt; ans; } /* 测试数据： 5 3 1 3 0 0 5 5 0 3 0 5 3 5 3 3 4 4 3 0 2 10 1 1 2 0 0 3 1 -2 0 -2 2 -2 4 -2 6 0 6 2 6 2 4 2 2 2 0 1 10 1 1 2 0 0 3 1 -2 0 -2 2 -2 4 -2 6 0 6 2 6 2 4 2 2 3 0 8 6 3 2 50000000 0 0 50000000 100000000 100000000 100000000 100000000 0 100000000 50000000 50000000 0 -100000000 50000000 0 50000000 0 100000000 2 */                                            