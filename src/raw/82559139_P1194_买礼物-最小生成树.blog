                                                                                                                                                         题目描述 又到了一年一度的明明生日了，明明想要买B" role="presentation">BBB样东西，巧的是，这B" role="presentation">BBB样东西价格都是A" role="presentation">AAA元。 但是，商店老板说最近有促销活动，也就是： 如果你买了第I" role="presentation">III样东西，再买第J" role="presentation">JJJ样，那么就可以只花KI,J" role="presentation">KI,JKI,JK_{I,J}元，更巧的是，KI,J" role="presentation">KI,JKI,JK_{I,J}竟然等于KJ,I" role="presentation">KJ,IKJ,IK_{J,I}。 现在明明想知道，他最少要花多少钱。 输入输出格式 输入格式： 第一行两个整数，A,B" role="presentation">A,BA,BA,B。 接下来B" role="presentation">BBB行，每行B" role="presentation">BBB个数，第I" role="presentation">III行第J" role="presentation">JJJ个为KI,J" role="presentation">KI,JKI,JK_{I,J}。 我们保证KI,J=KJ,I" role="presentation">KI,J=KJ,IKI,J=KJ,IK_{I,J}=K_{J,I}并且KI,I=0" role="presentation">KI,I=0KI,I=0K_{I,I}=0。 特别的，如果KI,J=0" role="presentation">KI,J=0KI,J=0K_{I,J}=0，那么表示这两样东西之间不会导致优惠。 输出格式： 一个整数，为最小要花的钱数。 输入输出样例   输入样例#1： 复制 1 1 0      输出样例#1： 复制 1       输入样例#2： 复制 3 3 0 2 4 2 0 2 4 2 0     输出样例#2： 复制 7     说明  样例解释2" role="presentation">222   先买第2" role="presentation">222样东西，花费3" role="presentation">333元，接下来因为优惠，买1,3" role="presentation">1,31,31,3样都只要2" role="presentation">222元，共7" role="presentation">777元。  （同时满足多个“优惠”的时候，聪明的明明当然不会选择用4" role="presentation">444元买剩下那件，而选择用2" role="presentation">222元。）  数据规模  对于30&amp;#x0025;" role="presentation">30%30%30\%的数据,1&amp;#x2264;B&amp;#x2264;10" role="presentation">1≤B≤101≤B≤101 \le B \le 10。  对于100&amp;#x0025;" role="presentation">100%100%100\%的数据,1&amp;#x2264;B&amp;#x2264;500,0&amp;#x2264;A,KI,J&amp;#x2264;1000" role="presentation">1≤B≤500,0≤A,KI,J≤10001≤B≤500,0≤A,KI,J≤10001 \le B \le 500,0 \le A,K_{I,J} \le 1000。        这是一道最小生成树的题目，解答这道题的关键就是把它转化成最小生成树模型，然后就基本上是裸的最小生成树啦。  但是还得注意两个问题。  一、“优惠购买”可能比原价还要贵，所以应该进行一下特判，如果选入的边比原价还要大的话，就按原价购买。  二、这个问题没有涉及，但应该考虑到的。那就是这张图可能不联通，所以应该判断有多少个联通块，再进行计算。  最后一个我自己的小问题，写代码时把n当成了m，以至于交了好几次莫名其妙全错。  AC Code    #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  struct Edge {     int from, to, cost;     Edge(int f, int t, int c): from(f), to(t), cost(c) {} };  bool cmp(Edge x, Edge y) {     return x.cost &lt; y.cost; }  const int maxn = 505; int n, m, father[maxn], ans = 0; vector&lt;Edge&gt; edge;  int find(int x) {     return x == father[x] ? x : father[x] = find(father[x]); }  int main() {     for (int i = 1; i &lt; maxn; ++i) {         father[i] = i;     }     cin &gt;&gt; n &gt;&gt; m;     for (int i = 1; i &lt;= m; ++i) {         for (int j = 1, c; j &lt;= m; ++j) {             cin &gt;&gt; c;             if (c == 0) continue;             edge.push_back(Edge(i, j, c));         }     }     sort(edge.begin(), edge.end(), cmp);     for (size_t i = 0; i &lt; edge.size(); ++i) {         int x = find(edge[i].from), y = find(edge[i].to);         int cost = edge[i].cost;         if (x == y) continue;         father[x] = y;         ans += cost &gt; n ? n : cost;     }     for (int i = 1; i &lt;= m; ++i) {         if (father[i] == i) ans += n;     }     cout &lt;&lt; ans; }                                            