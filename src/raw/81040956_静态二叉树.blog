                                                                                                                                                         二叉树也可以是静态的, 和指针的动态所不同的是,二叉树的静态是用结构体数组实现的, 访问指针变成了访问数组下标所在结点, 原来指针指向的位置变成了存储下标.  可以说这种方法对于不了解指针的人来说是非常友好了.  结构体定义:  struct Node {     int data, left, right; } node[maxn];  昨天我使用前序和后序构建静态二叉树时, 发现按照动态的方式无法构建, 今天早上醒来, 突然发现, 其实我面临的问题只有一个, 那就是, 动态分配内存对应静态里面是怎样的? 于是我发现其实就是给root赋一个递增的id, 表示给它分配的下标, 于是所谓”静态分配内存”就做好了.  由于下标id是递增的, 所以刚开始应该开辟结点数量上限大小的数组. 因此这部分空间也不算浪费.  二叉树可以写成静态的, 普通的树也可以. 只是普通的树的孩子结点是不确定的, 那么我们如何管理它的孩子节点呢? 像下面这样吗?  struct Node {     int data;     int child[maxn]; } node [Maxn];  非也非也, 如果是这样, 将会有巨大的空间浪费. 其实一个结点的孩子结点数量是不确定的, 那么我们可以用不定长数组vector去存储这些结点的下标, 从而节省空间.  struct Node {     int data;     vector&lt;int&gt; child; } node[maxn];    静态二叉树代码:  #include &lt;iostream&gt; using namespace std;  struct Node {     int data, left, right;     Node () { left = right = -1; } } node[10];  void init() // 初始化好一个静态的二叉树  {     node[1].data = 1;     node[1].left = 2;     node[1].right = 3;     node[2].data = 7;     node[2].left = 4;     node[2].right = -1;     node[3].data = 4;     node[3].left = -1;     node[3].right = 5;     node[4].data = 5;     node[4].left = -1;     node[4].right = -1;     node[5].data = 2;     node[5].left = -1;     node[5].right = -1; }  void preOrder(int root) {     if (root == -1) return;     cout &lt;&lt; node[root].data &lt;&lt; ' ';     preOrder(node[root].left);     preOrder(node[root].right); }  void inOrder(int root) {     if (root == -1) return;     inOrder(node[root].left);     cout &lt;&lt; node[root].data &lt;&lt; ' ';     inOrder(node[root].right); }  int main() {     init();     int root = 1;     preOrder(root);     cout &lt;&lt; endl;     inOrder(root); } /* 5 1 7 5 4 2 5 7 1 4 2 */    静态二叉树重构代码:  // 下面一行去掉, 我已经成功了!  // 好像无法完成? 静态的无法用这种方法重建二叉树  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  const int maxn = 1005; int id = 0;   struct Node {     int data, left, right;     Node () { left = right = -1; } } node[maxn];  int buildTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) {     if (pre.empty() || vin.empty()) return -1;     int val = pre[0], index = 0;     int root = ++id;     node[root].data = val;     while (vin[index] != val) index++;     vector&lt;int&gt; preLeft, preRight, vinLeft, vinRight;     for (int i = 0; i &lt; index; ++i) {         preLeft.push_back(pre[i + 1]);         vinLeft.push_back(vin[i]);     }     for (int i = index + 1; i &lt; pre.size(); ++i) {         preRight.push_back(pre[i]);         vinRight.push_back(vin[i]);     }     node[root].left = buildTree(preLeft, vinLeft);     node[root].right = buildTree(preRight, vinRight);     return root; }  void preOrder(int root) {     if (root == -1) return;     cout &lt;&lt; node[root].data &lt;&lt; ' ';     preOrder(node[root].left);     preOrder(node[root].right); }  void inOrder(int root) {     if (root == -1) return;     inOrder(node[root].left);     cout &lt;&lt; node[root].data &lt;&lt; ' ';     inOrder(node[root].right); }  void orderShow(int root) {     cout &lt;&lt; "the root node's id is : " &lt;&lt; root &lt;&lt; endl &lt;&lt; "前序遍历:" &lt;&lt; endl;      preOrder(root);     cout &lt;&lt; endl &lt;&lt; "中序遍历:" &lt;&lt; endl;      inOrder(root);     cout &lt;&lt; endl; }  int main() {     int n, x;     vector&lt;int&gt; pre, vin;     cin &gt;&gt; n;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         pre.push_back(x);     }     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         vin.push_back(x);     }     int root = buildTree(pre, vin);     orderShow(root); } /* 5 1 7 5 4 2 5 7 1 4 2 */                                            