                                                                                                                                                         汇编简单验证过程 .section .text .global _start _start:  movl $0x50f498cd, %eax  movl $0x0fcbd60b, %edx  movzbl %dh, %eax    movl $1, %eax  movl $0, %ebx  int $0x80  然后使用命令 gcc -g -c test2.s -o test2.o 编译 使用命令 ld test2.o -o test2 链接 然后就可以调试了 gdb test2 使用 info reg 输出寄存器的值。 汇编 1、movb、movw、movl 的操作数固定，不能有不同 2、MOVS做符号扩展，低位传到高位，有三种情况 movsbw、movsbl、movswl 3、MOVZ做零扩展，低位传到高位，有三种情况 movzbw、movzbl、movzwl 有一些容易混淆的情况 mov (%eax), %dx push、pop只有pushl、popl movb $0xF, (%bl) 错误，%bl是8位，不能用来做地址 movw (%eax), 4(%esp) 后缀啊什么的看着没毛病，但是不能同时出现两个存储器引用  既然mov没有从高位转向低位的操作，那么又是如何进行强制类型转换的呢？ 我写了一个小程序来测试一下 c代码 #include &lt;stdio.h&gt;  char test() {  int a = 97;  char b;  b = a;  return b; }  int main() {  int c = test(); }  得到的汇编源码是这样的：  从这一步看  可见a存到b时，数值全部mov到中间寄存器，然后在截取低8位到栈上，由此完成了强制类型转换。 函数返回时，要把值存到%eax中，那么就做零扩展，存到寄存器中。                                              