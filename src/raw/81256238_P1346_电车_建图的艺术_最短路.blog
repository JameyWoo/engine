                                                                                                                                                         P1346 电车 传送门     题目描述    在一个神奇的小镇上有着一个特别的电车网络，它由一些路口和轨道组成，每个路口都连接着若干个轨道，每个轨道都通向一个路口（不排除有的观光轨道转一圈后返回路口的可能）。在每个路口，都有一个开关决定着出去的轨道，每个开关都有一个默认的状态，每辆电车行驶到路口之后，只能从开关所指向的轨道出去，如果电车司机想走另一个轨道，他就必须下车切换开关的状态。      为了行驶向目标地点，电车司机不得不经常下车来切换开关，于是，他们想请你写一个程序，计算一辆从路口A到路口B最少需要下车切换几次开关。      输入输出格式 输入格式： 第一行有3个整数2&lt;=N&lt;=100，1&lt;=A，B&lt;=N，分别表示路口的数量，和电车的起点，终点。      接下来有N行，每行的开头有一个数字Ki(0&lt;=Ki&lt;=N-1)，表示这个路口与Ki条轨道相连，接下来有Ki个数字表示每条轨道所通向的路口，开关默认指向第一个数字表示的轨道。      输出格式： 输出文件只有一个数字，表示从A到B所需的最少的切换开关次数，若无法从A前往B，输出-1。      输入输出样例    输入样例#1：     3 2 1    2 2 3    2 3 1    2 1 2    输出样例#1：     0   这道题最关键的是建图  如果不理解的话可能会觉得非常奇怪,感觉好难写,怎么判断开不开开关呢? 好像很复杂.  其实就是默认的边权为0,其他为1,然后求最短路径即可   我打算用spfa写  其实数据很水， 用floyd都可以过的。  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std;  struct Edge {     int to, cost;     Edge (int t, int c) : to(t), cost(c) {} };  const int maxn = 105; int n, start, end, dis[maxn]; bool in[maxn] = {}; vector&lt;Edge&gt; edge[maxn];  void spfa(int start) {     queue&lt;int&gt; que;     dis[start] = 0;     que.push(start);     in[start] = true;     while (!que.empty()) {         int node = que.front();         que.pop();         in[node] = false;         for (int i = 0; i &lt; edge[node].size(); ++i) {             int v = edge[node][i].to;             int cost = edge[node][i].cost;             if (dis[v] &gt; dis[node] + cost) {                 dis[v] = dis[node] + cost;                 if (!in[v]) {                     que.push(v);                     in[v] = true;                 }             }         }     } }  int main() {     memset(dis, 0x3f, sizeof(dis));     cin &gt;&gt; n &gt;&gt; start &gt;&gt; end;     for (int i = 1; i &lt;= n; ++i) {         int k, x;         cin &gt;&gt; k;         if (k &gt; 0) {             cin &gt;&gt; x;             edge[i].push_back(Edge(x, 0));         }         for (int j = 1; j &lt; k; ++j) {             cin &gt;&gt; x;             edge[i].push_back(Edge(x, 1));         }     }     spfa(start);     if (dis[end] == 0x3f3f3f3f) cout &lt;&lt; -1;     else cout &lt;&lt; dis[end]; }                                            