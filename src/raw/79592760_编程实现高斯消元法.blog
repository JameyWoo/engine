                                                                                                                                                         计算机计算线性方程组的解一般是用高斯消元法完成的.  我写了一个简单的程序, 输入一个[(n*(n+1)]的增广矩阵, 求解各未知数的值.  只能解答两种情况:  1. 线性方程组有唯一解   2. 线性方程组无解  时间复杂度为O(n^3).  #include &lt;iostream&gt; #include &lt;cmath&gt; const double ESP = 1e-8; using namespace std;  int main() {     int n;     double a[105][105];     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         for(int j = 0; j &lt;= n; ++j) {             cin &gt;&gt; a[i][j];         }     }      //消去的过程      for(int i = 1; i &lt; n; ++i) {         for(int j = i; j &lt; n; ++j) {             double tmp = a[j][i-1];             for(int k = i-1; k &lt;= n; ++k) {                 a[j][k] = a[j][k]*(a[i-1][i-1]/tmp) - a[i-1][k];             }         }     }      //整理出结果的过程     bool flag = 0; //判断是否无解      for(int i = n-1; i &gt;= 0; --i) {         for(int j = i - 1; j &gt;= 0; --j) {             a[j][n] -= a[i][n]*(a[j][i]/a[i][i]);             a[j][i] = 0;         }         if(fabs(a[i][i]) &gt; ESP &amp;&amp; fabs(a[i][n]) &lt;= ESP)             flag = 1;     }      for(int i = 0; i &lt; n; ++i) {         for(int j = 0; j &lt;= n; ++j) {             cout.setf(ios::fixed);             cout.precision(3);             cout.width(8);             cout &lt;&lt; left &lt;&lt; a[i][j];         }         cout &lt;&lt; endl &lt;&lt; endl;     }      if(flag) {         cout &lt;&lt; "无解 !!!\n";     } else {         for(int i = 0; i &lt; n; ++i) {             cout.setf(ios::fixed);             cout.precision(3);             cout &lt;&lt; "x" &lt;&lt; i + 1 &lt;&lt; " = " &lt;&lt; a[i][n]/a[i][i] &lt;&lt; endl;         }     } } /* 2 1 2 3 2 1 1  2 1 2 1 2 1 1  3 1 2 3 4 2 3 4 1 3 4 1 2  4 1 2 3 4 0 2 3 4 1 0 3 4 1 2 0 4 1 2 3 0 */                                            