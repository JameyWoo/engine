                                                                                                                                                         传送门     题目背景 AA 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。      题目描述 给出A地区的村庄数 NN ，和公路数 MM    ，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）      输入输出格式 输入格式： 第 11 行两个正整数 N,MN,M      下面 MM 行，每行 33 个正整数 x, y, tx,y,t ，告诉你这条公路连着 x,yx,y 两个村庄，在时间t时能修复完成这条公路。      输出格式： 如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 -1−1 ，否则输出最早什么时候任意两个村庄能够通车。      输入输出样例      输入样例#1：     4 4    1 2 6    1 3 4    1 4 5    4 2 3    输出样例#1：     5   此题一看,觉得是按照时间排序,然后一条一条边加过去,所有边都联通了那么就ok了  问题是: 什么时候知道所有的边都联通了?  使用并查集是没错的, 但裸的并查集还不能解决问题   难道每加入一个边都判断一下是否所有的点都在同一个集合里面? 这样是肯定会超时的.  for (int k = 1; k &lt;= n; ++k) { // 更新每个结点的祖先     find(k);  int tmp = father[1]; bool flag = false; for (int j = 1; j &lt;= n; ++j) {             if (tmp != father[j]) {                 flag = true;                 continue;             }         }         if (flag == false) {             ans = Edge[i].t;             break;         }  不论如何,先这样暴力地求解一下.   woc, 这题地数据稍微有点水, 写得这么暴力都得了90分.  那么接下来如何让它“温柔”一点呢?   我觉得数据这么大, 读入这么多数, 是不是应该换成scanf来读入数据?   还是90分,果然像就这么水过去是不现实的,虽然其他的时间减少了,但超时的还是超时  那么接下来有什么办法?   Oh, yes! 想到解决方法了!!! 真棒!  可以建立一个count数组, 这个数组记录的是以该点为祖先的结点数量,初始化时全为1.  什么时候可以判断所有的点祖先相同呢?  就是当某个count元素的值为n(结点个数)时. 如果每次都遍历一遍count数组,那么时间复杂度和之前一样, 但是, 我们可以规定性地设定某个节点为最高级祖先(比如1), 那么每次加入边的时候就对它进行判断,如果其中有1,那么1作为祖先,否则照旧.同时转移count值, 每插入一条边判断count[1]的数量就OK了.  每个样例时间都不超过100ms.    我靠! 看了下题解! 惊醒梦中人! 这就是一道最小生成树问题! 用并查集的Kruskal算法! 写过这么多次居然没反应过来! 尴尬了!   不过我的方法也不错  关键是启发了我想出一种统计祖先数量的方法!   完整代码  #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;  struct edge {     int u, v, t;     edge(int u, int v, int t) : u(u), v(v), t(t) {} }; vector&lt;edge&gt; Edge; int father[1005]; int cnt[1005] = {};   bool cmp(edge x, edge y) {     return x.t &lt; y.t; }  int find(int x) {     return x == father[x] ? x : father[x] = find(father[x]); }  int main() {     int n, m, ans = -1;     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt;= n; ++i) father[i] = i, cnt[i] = 1;     for (int i = 0; i &lt; m; ++i) {         int u, v, t;         scanf("%d %d %d", &amp;u, &amp;v, &amp;t);         Edge.push_back(edge(u, v, t));      }      sort(Edge.begin(), Edge.end(), cmp);     for (int i = 0; i &lt; Edge.size(); ++i) {         int u = Edge[i].u, v = Edge[i].v;         u = find(u), v = find(v);         if (u != v) {             if (u == 1) {                 father[v] = 1;                 cnt[1] += cnt[v];             } else if (v == 1) {                 father[u] = 1;                 cnt[1] += cnt[u];             } else {                 father[v] = u;                 cnt[u] += cnt[v];             }         }         if (cnt[1] == n) {             cout &lt;&lt; Edge[i].t;             return 0;         }     }     cout &lt;&lt; -1; } /*  4 4 1 2 6 1 3 4 1 4 5 4 2 3 */                                             