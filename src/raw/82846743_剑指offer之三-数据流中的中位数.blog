                                                                                                                                                         问题描述 对于一个数据流, 每读入一个数据, 就输出已读入数据的中位数.  这道题有很多种方法. 一. 暴力一点的是有序数组, 读入一个数据就将其有序化, 然后直接输出中位数. 这样插入一个数复杂度为O(n), 查找为O(1); 二. 或者使用有序链表, 插入的复杂度为O(n), 查找为O(1). 为什么查找中位数可以是O(1)? 因为可以定义两个指针, 分别指向中间的两个数, 如果总数为奇数则同时指向最中间的数. 在插入的过程中, 我们可以记录遍历的位置, 判断是在左边插入还是右边, 从而可以调整中间指针所指向的位置. 这种思路非常巧妙. 但无论是有序数组或是有序链表, 插入的复杂度都有些过高了. 三. 于是我们可以使用二叉搜索树, 于是插入的平均时间复杂度为O(logn), 查找也为O(logn). 但是在极端情况下, 由于二叉搜索树本身不具有平衡性, 所以可能成链状, 最坏会退化成O(n)的插入和查找操作. 四. 针对这个问题, 我们可以使用二叉平衡搜索树(AVL树), 这样插入的时间复杂度为O(logn), 同时利用AVL树的特殊性, 找到中位数只需O(1)的时间. 五. 另一种方法是使用堆, 最大堆+最小堆. 这两个堆把数据流分成两部分, 插入的操作O(logn), 查询操作O(1). 具体如何实现? 对于第i个数, 当i - 1 为奇数, 向最大堆插入, 如果最大堆最大大于最小堆最小, 则交换, 同时向下调整; 当i - 1为偶数, 向最小堆插入, 如果有最大堆大于最小堆最小, 则交换, 同时向下调整. 六. 也可以使用红黑树, 它们的功能都是类似的. 因为红黑树比较难写, 省时些的话, 直接利用 STL的multiset 即可. 给出五和六的代码实现, 随机种子是一样的, 这意味着我们的随机数组相同, 因此大家可以对比输出结果, 会发现这两份代码的结果是一样的. 五: #include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; #define RAND(l, r) l+(int)(r-l+1)*rand()/(RAND_MAX+1) using namespace std; const int maxn = 100;  void rand_data(int data[], int n) {  srand(1999);  for (int i = 0; i &lt; n; ++i) {   data[i] = RAND(1, 100);  } }  void max_down_adjust(int *heap, int low, int high) {  int i = low, j = 2 * low;  while (j &lt;= high) {   if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) {    j = j + 1;   }   if (heap[i] &lt; heap[j]) {    swap(heap[i], heap[j]);    i = j;    j = 2 * i;   } else break;  } }  void min_down_adjust(int *heap, int low, int high) {  int i = low, j = 2 * low;  while (j &lt;= high) {   if (j + 1 &lt;= high &amp;&amp; heap[j + 1] &lt; heap[j]) {    j++;   }   if (heap[i] &gt; heap[j]) {    swap(heap[i], heap[j]);    i = j;    j = 2 * i;   } else break;  } }  void max_insert(int *heap, int n, int data) {  heap[n] = data;  int i = n, j = n &gt;&gt; 1;  while (j &gt;= 1) {   if (heap[i] &gt; heap[j]) {    swap(heap[i], heap[j]);    i = j;    j = i &gt;&gt; 1;   } else break;  } }  void min_insert(int *heap, int n, int data) {  heap[n] = data;  int i = n, j = n &gt;&gt; 1;  while (j &gt;= 1) {   if (heap[i] &lt; heap[j]) {    swap(heap[i], heap[j]);    i = j;    j = i &gt;&gt; 1;   } else break;  } }  int main() {  int n = maxn, data[maxn];  int max_heap[maxn] = {}, min_heap[maxn] = {};  rand_data(data, n);  cout &lt;&lt; "这些随机数是:" &lt;&lt; endl;  for (int i = 0; i &lt; n; ++i) {   printf("%4d", data[i]);   if ((i + 1)%8 == 0) cout &lt;&lt; endl;  }  cout &lt;&lt; endl;  for (int i = 0; i &lt; n; ++i) {   if (i &amp; 1) { // 为奇数, 向最大堆插入, 如果最大堆最大大于最小堆最小, 则交换, 同时向下调整.    max_insert(max_heap, (i &gt;&gt; 1) + 1, data[i]);    if (max_heap[1] &gt; min_heap[1]) {     swap(max_heap[1], min_heap[1]);     max_down_adjust(max_heap, 1, (i &gt;&gt; 1) + 1);     min_down_adjust(min_heap, 1, (i &gt;&gt; 1) + 1);    }    cout &lt;&lt; ((max_heap[1] + min_heap[1]) &gt;&gt; 1) &lt;&lt; endl;   } else { // 为偶数, 向最小堆插入, 如果有最大堆大于最小堆最小, 则交换, 同时向下调整.    min_insert(min_heap, (i &gt;&gt; 1) + 1, data[i]);    if (max_heap[1] &gt; min_heap[1]) {     swap(max_heap[1], min_heap[1]);     max_down_adjust(max_heap, 1, i &gt;&gt; 1);     min_down_adjust(min_heap, 1, (i &gt;&gt; 1) + 1);    }    cout &lt;&lt; min_heap[1] &lt;&lt; endl;   }  } }  六: #include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; #include &lt;set&gt; #define RAND(l, r) l+(int)(r-l+1)*rand()/(RAND_MAX+1) using namespace std; const int maxn = 100;  void rand_data(int data[], int n) {  srand(1999);  for (int i = 0; i &lt; n; ++i) {   data[i] = RAND(1, 100);  } }  int main() {  multiset&lt;int&gt; min_heap;  multiset&lt;int, greater&lt;int&gt; &gt; max_heap;  int n = maxn, data[maxn];  rand_data(data, n);  cout &lt;&lt; "这些随机数是:" &lt;&lt; endl;  for (int i = 0; i &lt; n; ++i) {   printf("%4d", data[i]);   if ((i + 1)%8 == 0) cout &lt;&lt; endl;  }  cout &lt;&lt; endl;  for (int i = 0; i &lt; n; ++i) {   if (i &amp; 1) {    max_heap.insert(data[i]);    if (*max_heap.begin() &gt; *min_heap.begin()) {     int a = *max_heap.begin(), b = *min_heap.begin();     max_heap.erase(max_heap.begin());     min_heap.erase(min_heap.begin());     max_heap.insert(b);     min_heap.insert(a);    }    printf("%d\n", (*max_heap.begin() + *min_heap.begin()) / 2);   } else {    min_heap.insert(data[i]);    if (*max_heap.begin() &gt; *min_heap.begin()) {     int a = *max_heap.begin(), b = *min_heap.begin();     max_heap.erase(max_heap.begin());     min_heap.erase(min_heap.begin());     max_heap.insert(b);     min_heap.insert(a);    }    cout &lt;&lt; *min_heap.begin() &lt;&lt; endl;   }  } }                                               