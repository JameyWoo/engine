                                                                                                                                                         这是我做过的最简单的第三题, 一遍就过了. 按照题目要求的进行字符串转换即可.  要是今年九月份的CCF认证有这么简单就好了.  既然分了区块和行内两种层次, 那么首先应该划分区块,然后对区块的内容分别处理   先进行区块划分   输入文本里的空行应该是”“, 空字符, 也没有换行表示什么的.  用一个函数分别对每个区块进行解析  处理段落 处理标题, 注意字符串拼接, 还是一个一个接比较好.    #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  void em (string &amp;line) {     string tmp = "";     int cnt = 0;     for (int i = 0; i &lt; line.size(); ++i) {         if (line[i] == '_') {             cnt++;             if (cnt % 2 == 1) {                 tmp += "&lt;em&gt;";             } else tmp += "&lt;/em&gt;";         } else tmp += line[i];     }     line = tmp; }  string turn(string content) {     string tmp = "&lt;a href=\"";     int i;     for (i = 0; content[i] != '('; ++i) ;     ++i;     while (content[i] != ')') {         tmp += content[i];         i++;     }     tmp += "\"&gt;";     for (i = 1; content[i] != ']'; ++i) tmp += content[i];     tmp += "&lt;/a&gt;";     return tmp; }  void href (string &amp;line) {     string tmp, temp;     bool on = false;     for (int i = 0; i &lt; line.size(); ++i) {         if (line[i] == '[') on = true;         if (on) tmp += line[i];         else temp += line[i];          if (line[i] == ')') {             on = false;             temp += turn(tmp);             tmp = "";         }     }     line = temp; }  void transfer(vector&lt;string&gt; &amp;block) {     if (block[0][0] == '#') {         for (int i = 0; i &lt; block.size(); ++i) {             int j, cnt = 0;             for (j = 0; block[i][j] == '#'; ++j) {                 cnt++;             }             string tmp = "&lt;h";             tmp += char(cnt + '0');             tmp += '&gt;';             while (block[i][j] == ' ') ++j;             for (int k = j; k &lt; block[i].size(); ++k)                 tmp += block[i][k];             tmp += "&lt;/h";             tmp += char(cnt + '0');             tmp += '&gt;';             em(tmp);             href(tmp);             block[i] = tmp;         }     } else if (block[0][0] == '*') {         for (int i = 0; i &lt; block.size(); ++i) {             while (block[i][0] == ' ' || block[i][0] == '*') block[i].erase(block[i].begin());         }         block[0] = "&lt;ul&gt;\n&lt;li&gt;" + block[0] + "&lt;/li&gt;";         for (int i = 1; i &lt; block.size(); ++i) {             block[i] = "&lt;li&gt;" + block[i] + "&lt;/li&gt;";         }         block.back() += "\n&lt;/ul&gt;";         for (int i = 0; i &lt; block.size(); ++i) {             em(block[i]);             href(block[i]);         }     } else {         block[0] = "&lt;p&gt;" + block[0];         block.back() += "&lt;/p&gt;";         for (int i = 0; i &lt; block.size(); ++i) {             em(block[i]);             href(block[i]);         }     } }  void show(vector&lt;string&gt; blocks[105], int id) {     for (int i = 0; i &lt;= id; ++i) {         for (int j = 0; j &lt; blocks[i].size(); ++j) {             cout &lt;&lt; blocks[i][j] &lt;&lt; endl;         }     } }  int main() {     string line, last;     bool isfirst = false;     vector&lt;string&gt; blocks[105];     int id = 0;     while (getline(cin, line)) {         if (isfirst == false) {             if (line != "") {                 isfirst = true;             blocks[id].push_back(line);             }         } else {             if (line != "" &amp;&amp; last == "") {                 blocks[++id].push_back(line);             } else if (line != "") blocks[id].push_back(line);         }         last = line;     }     for (int i = 0; i &lt;= id; ++i) {         transfer(blocks[i]);     }      show(blocks, id); }                                            