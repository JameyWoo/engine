                                                                                                                                                         这道题是洛谷上提高+/省选-的题目.  看上去是道简单的斐波那契数列, 可是看看数据范围, 用普通的递推方式肯定超时.  那么这道题该怎么做呢?  标准的做法似乎是矩阵快速幂(题解提到),  然而笔者还不会, 再看题解, 发现有其他的方法. 是一个从没见过或者见过但没有印象的斐波那契数的性质  f(2n) = f(n+1)^2 - f(n-1)^2;  f(2n+1) = f(n+1)^2 + f(n)^2;  这样的话, 求解一个很大的n, 就可以对折求解了, 时间复杂度为O(logn)?  应该是吧.  方法是用递归, 记忆化搜索, 但是记忆的结果不是储存在数组里面的, 而是储存在map里, 因为开不了这么大的数组(结果是离散的, 并不连续)  因为map的缘故, 效率比矩阵快速幂要低了不少, 不过  对于蒟蒻的我来说, 比赛的时候更愿意用这种方法. 因为它更好写, 而且能AC.  附代码  #include &lt;bits/stdc++.h&gt; #define N 1000000007  using namespace std;  map &lt; long long, long long &gt; mm;  long long fib(long long n) {     if(n == 1) return 1;     if(n == 2) return 1;     if(mm.find(n) == mm.end()) {         if(n%2 == 0) mm[n] = fib(n/2+1)*fib(n/2+1) % N - fib(n/2-1)*fib(n/2-1) % N;         else mm[n] = fib((n+1)/2) * fib((n+1)/2) % N + fib((n-1)/2) * fib((n-1)/2) % N;     }     return mm[n]; }  int main() {     mm[1] = 1, mm[2] = 1;     long long n;     cin &gt;&gt; n;     cout &lt;&lt; fib(n) % N; }                                            