                                                                                                                                                         P1113 杂务 传送门   题目描述 John的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 11 。John有需要完成的 nn 个杂务的清单，并且这份清单是有一定顺序的，杂务 k(k&gt;1)k(k&gt;1) 的准备工作只可能在杂务 11 至 k-1k−1 中。   写一个程序从 11 到 nn 读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。   输入输出格式 输入格式：  第1行：一个整数 nn ，必须完成的杂务的数目( 3 \le n \le 10,0003≤n≤10,000 )；   第 22 至 (n+1)(n+1) 行： 共有 nn 行，每行有一些用 11 个空格隔开的整数，分别表示：     工作序号( 11 至 nn ,在输入文件中是有序的)；      完成工作所需要的时间 len(1 \le len \le 100)len(1≤len≤100) ；      一些必须完成的准备工作，总数不超过 100100 个，由一个数字 00 结束。有些杂务没有需要准备的工作只描述一个单独的 00 ，整个输入文件中不会出现多余的空格。     输出格式：  一个整数，表示完成所有杂务所需的最短时间。   输入输出样例 输入样例#1：   7  1 5 0  2 2 1 0  3 3 2 0  4 6 1 0  5 1 2 4 0  6 8 2 4 0  7 4 3 5 6 0  输出样例#1：   23   看描述的时候就觉得肯定和拓扑排序有关了, 看完整道题发现大概就是一道DAG最长路的题目  可以用DP来解决,或者是很复杂度关键路径  因为DP写的比较简单,所以此代码用DP写.  注意: 这种问题被叫做DAG最长路.明明是求最短的时间,为什么叫做最长路呢?这是因为虽然是最短的时间,但是我们要找到路径里面最长的,能够到终点的路,这条路上的杂物处理好了,其他的都可以处理好的,而反之,如果这其他的路都处理好了,而这条路没处理好,那么任务就不算完成.   由于题目数据的输入一定是准备工作在前面, 所以可以取巧, 每次输入都处理好这个点的结果.后面的数据实不会对前面的产生影响的.  #include &lt;iostream&gt; using namespace std;  const int maxn = 10000 + 5; int ans[maxn] = {};  int main() {     int n, _max = -1;     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         int u, time, x;         cin &gt;&gt; u &gt;&gt; time;         int tmp = 0;         while (cin &gt;&gt; x &amp;&amp; x)              tmp = max(ans[x], tmp);         ans[u] = tmp + time;     }     for (int i = 1; i &lt;= n; ++i)         _max = max(_max, ans[i]);     cout &lt;&lt; _max; }  还有一份长度BFS的代码    #include &lt;iostream&gt; #include &lt;vector&gt;  #include &lt;cstring&gt;  #include &lt;queue&gt; using namespace std;  const int maxn = 10000 + 5; const int INF = 0x3f3f3f3f; vector&lt;int&gt; G[maxn]; int cost[maxn] = {}; // 处理完这个事件花费的时间  int time[maxn] = {}; // 一个事件的处理时间  bool in[maxn] = {};   void DAG() {     cost[1] = time[1];     queue&lt;int&gt; que;     que.push(1);     in[1] = true;     while (!que.empty()) {         int u = que.front();         que.pop();         in[u] = false;         for (int i = 0; i &lt; G[u].size(); ++i) {             int v = G[u][i];             cost[v] = max(cost[v], cost[u] + time[v]);             if (!in[v]) {                 in[v] = true;                 que.push(v);             }         }     } }  int main() {     int n;     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         cost[i] = -1;     }      for (int i = 1; i &lt;= n; ++i) {         int u, x;         cin &gt;&gt; u &gt;&gt; time[i];         while (cin &gt;&gt; x &amp;&amp; x) {             G[x].push_back(u);         }     }     DAG();     int _max = 0;     for (int i = 1; i &lt;= n; ++i) {         _max = max(_max, cost[i]);     }     cout &lt;&lt; _max; }                                            