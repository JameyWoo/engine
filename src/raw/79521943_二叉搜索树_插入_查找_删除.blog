                                                                                                                                                            声明: 第一次写二叉搜索树, 可能会有bug   这棵二叉搜索树以中序遍历的方式输出, 所以插入(存储的规则也是按照中序遍历的规则)  #include &lt;iostream&gt; using namespace std;  struct Node {     int key;     Node *parent, *left, *right; };  Node *root, *NIL;  //根节点和一个空结点   void insert(int key) {     Node *z = new Node;  //z就是新插入的结点      z-&gt;key = key;     z-&gt;left = z-&gt;right = NIL;     Node *y = NIL;  //y将是z的上一个结点,更新z的parent     Node *x = root;  //x指向root, 因为要从root开始遍历      while(x != NIL) {         y = x; //不断更新y, y从上一个x变成当前x          if(key &lt; x-&gt;key) {  //小的向左遍历             x = x-&gt;left;         } else x = x-&gt;right; //大于等于的向右遍历     }      z-&gt;parent = y;  //确立了z的父节点     if(y == NIL) root = z;     else {         if(key &lt; y-&gt;key) y-&gt;left = z;         else y-&gt;right = z;      } }  void inOrder(Node *u) {     if(u == NIL) return;     inOrder(u-&gt;left);     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     inOrder(u-&gt;right); }  void preOrder(Node *u) {     if(u == NIL) return;     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     preOrder(u-&gt;left);     preOrder(u-&gt;right); }  int main() {     int n, x;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         insert(x);     }     inOrder(root); //中序遍历     cout &lt;&lt; endl;     preOrder(root); }  /* 8 30 88 12 1 20 17 25 66 */  下面多了一个查找    #include &lt;iostream&gt; using namespace std;  struct Node {     int key;     Node *parent, *left, *right; };  Node *root, *NIL;  //根节点和一个空结点   void insert(int key) {     Node *z = new Node;  //z就是新插入的结点      z-&gt;key = key;     z-&gt;left = z-&gt;right = NIL;     Node *y = NIL;  //y将是上一个z的上一个结点,更新z的parent     Node *x = root;  //x存储root, 因为要从root开始遍历      while(x != NIL) {         y = x; //不断更新y, y从上一个x变成当前x          if(key &lt; x-&gt;key) {  //小的向左遍历             x = x-&gt;left;         } else x = x-&gt;right; //大于等于的向右遍历     }      z-&gt;parent = y;  //确立了z的父节点     if(y == NIL) root = z;     else {         if(key &lt; y-&gt;key) y-&gt;left = z;         else y-&gt;right = z;      } }  void inOrder(Node *u) {     if(u == NIL) return;     inOrder(u-&gt;left);     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     inOrder(u-&gt;right); }  void preOrder(Node *u) {     if(u == NIL) return;     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     preOrder(u-&gt;left);     preOrder(u-&gt;right); }  Node * find(int key) {     Node *x = root;     while(x != NIL) {         if(x-&gt;key == key) return x;         if(key &lt; x-&gt;key) x = x-&gt;left;         else x = x-&gt;right;     }     return NIL; }  int main() {     int n, x;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         insert(x);     }     inOrder(root); //中序遍历     cout &lt;&lt; endl;     preOrder(root);     cout &lt;&lt; endl;     for(int i = 0; i &lt; 7; ++i) {         cin &gt;&gt; x;         Node *y = find(x);         if(y != NIL) {             cout &lt;&lt; "find it\n";             cout &lt;&lt; "it's parent is " &lt;&lt; y-&gt;parent-&gt;key &lt;&lt; '\n';             cout &lt;&lt; "it's left is " &lt;&lt; y-&gt;left &lt;&lt; '\n';             cout &lt;&lt; "it's right is " &lt;&lt; y-&gt;right &lt;&lt; '\n' &lt;&lt; '\n';         } else cout &lt;&lt; "didn't find it\n\n";     }  }  /* 8 30 88 12 1 20 17 25 66  1 2 11 12 34 33 66  */  二叉搜索树的删除操作  #include &lt;iostream&gt; using namespace std;  struct Node {     int key;     Node *parent, *left, *right; };  Node *root, *NIL;  //根节点和一个空结点   void insert(int key) {     Node *z = new Node;  //z就是新插入的结点      z-&gt;key = key;     z-&gt;left = z-&gt;right = NIL;     Node *y = NIL;  //y将是上一个z的上一个结点,更新z的parent     Node *x = root;  //x存储root, 因为要从root开始遍历      while(x != NIL) {         y = x; //不断更新y, y从上一个x变成当前x          if(key &lt; x-&gt;key) {  //小的向左遍历             x = x-&gt;left;         } else x = x-&gt;right; //大于等于的向右遍历     }      z-&gt;parent = y;  //确立了z的父节点     if(y == NIL) root = z;     else {         if(key &lt; y-&gt;key) y-&gt;left = z;         else y-&gt;right = z;      } }  void inOrder(Node *u) {     if(u == NIL) return;     inOrder(u-&gt;left);     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     inOrder(u-&gt;right); }  void preOrder(Node *u) {     if(u == NIL) return;     cout &lt;&lt; u-&gt;key &lt;&lt; ' ';     preOrder(u-&gt;left);     preOrder(u-&gt;right); }  Node * find(int key) {     Node *x = root;     while(x != NIL) {         if(x-&gt;key == key) return x;         if(key &lt; x-&gt;key) x = x-&gt;left;         else x = x-&gt;right;     }     return NIL; }  void Delete(int key) {     Node *x = root;     while(x != NIL) {         if(x-&gt;key == key) {             if(x-&gt;left == NIL) {                 x-&gt;parent-&gt;right = x-&gt;right;                 x-&gt;right-&gt;parent = x-&gt;parent;             }             else {                 x-&gt;parent-&gt;right = x-&gt;left;                 x-&gt;left-&gt;parent = x-&gt;parent;                 x-&gt;right-&gt;parent = x-&gt;left;                 x-&gt;left-&gt;right = x-&gt;right;             }             return;         }         if(key &lt; x-&gt;key) x = x-&gt;left;         else x = x-&gt;right;     } }  int main() {     int n, x;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         insert(x);     }     inOrder(root); //中序遍历     cout &lt;&lt; endl;     preOrder(root);     cout &lt;&lt; endl;     Delete(20);     cout &lt;&lt; endl;     inOrder(root); //中序遍历     cout &lt;&lt; endl;     preOrder(root);     cout &lt;&lt; endl; }  /* 8 30 88 12 1 20 17 25 66  1 2 11 12 34 33 66  */                                            