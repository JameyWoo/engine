                                                                                                                                                         全排列是什么?     比如1 2 3 这三个数的全排列是:    1 2 3    1 3 2    2 1 3    2 3 1    3 1 2    3 2 1   用DFS生成一个序列的全排列很方便也很简单.  同样, 用搜索树的概念去理解这样的一个过程  时间复杂度为O(n!)  一道全排列的问题  基本是裸的回溯了  #include &lt;bits/stdc++.h&gt; using namespace std; int n, vis[10] = {}; vector &lt;int&gt; vec;  void dfs(int t) {     if(t == n + 1) {         for(int i = 0; i &lt; n; ++i) {             printf("    %d", vec[i]);         }         cout &lt;&lt; endl;     }     for(int i = 1; i &lt;= n; ++i) {         if(vis[i]) continue;         vis[i] = 1; vec.push_back(i);         dfs(t+1);         vis[i] = 0; vec.pop_back();     } }  int main() {     cin &gt;&gt; n;     dfs(1); }  全排列是没有重复的, 考虑另一种情况, 有重复元素的排列  把vis[]去掉即可, 因为vis的作用就是限制只能选一次的  还有, 加上超范围跳出函数  之前的程序不用加, 是因为之前所有的数都会排列, 全部vis置一之后就结束了    #include &lt;bits/stdc++.h&gt;  using namespace std; int n, vis[10] = {}; vector &lt;int&gt; vec;  void dfs(int t) {     if(t == n + 1) {         for(int i = 0; i &lt; n; ++i) {             printf("    %d", vec[i]);         }         cout &lt;&lt; endl;     }     for(int i = 1; i &lt;= n; ++i) {         if(vis[i]) continue;         vis[i] = 1; vec.push_back(i);         dfs(t+1);         vis[i] = 0; vec.pop_back();     } }  int main() {     cin &gt;&gt; n;     dfs(1); }                                            