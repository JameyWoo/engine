                                                                                                                                                         时隔这么久又重新学算法, 惭愧.  此题是牛客网一次比赛题, 拖了很久, 不过认真思考去做, 发现其实很简单.  简单地画个图, 推导一下排序过程, 就OK了.  百度了一下, 发现关于栈排序的博客大都是双栈全排的, 大概那个要更复杂些.  不多说  栈和排序     时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K 64bit IO Format:    %lld 题目描述 给你一个1-&gt;n的排列和一个栈，入栈顺序给定 你要在不打乱入栈顺序的情况下，对数组进行从大到小排序    当无法完全排序时，请输出字典序最大的出栈序列 输入描述:      第一行一个数n 第二行n个数，表示入栈的顺序，用空格隔开，结尾无空格      输出描述:      输出一行n个数表示答案，用空格隔开，结尾无空格      示例1 输入      5 2 1 5 3 4      输出      5 4 3 1 2      说明      2入栈；1入栈；5入栈；5出栈；3入栈；4入栈；4出栈；3出栈；1出栈；2出栈      备注:      对于100%的数据，有1&lt;=n&lt;=1000000，保证给的是一个排列   代码: (40行)  #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int INF = 1e8;  bool cmp(int a, int b) {     return a &gt; b; }  int main( ) {     int n;     cin &gt;&gt; n;     int *que = new int [n];     int *que_2 = new int [n];   //a queue as a copy     int *st = new int [n];      //the stack/the answer     for( int i = 0; i &lt; n; ++i ) {         cin &gt;&gt; que[i];         que_2[i] = que[i];     }     sort(que_2, que_2 + n, cmp);    //sort from big to small     int start = 0, t = 0;     for( int i = 0; i &lt; n; ++i ) {         if(que[i] == que_2[start]) {             start++;             st[t++] = que[i];             que[i] = INF;         }     }     for( int i = n-1; i &gt;= 0; --i ) {         if( que[i] != INF ) {             st[t++] = que[i];         }     }     for( int i = 0; i &lt; t-1; ++i ) {         cout &lt;&lt; st[i] &lt;&lt; ' ';     }     cout &lt;&lt; st[t-1]; }                                            