                                                                                                                                                         传送门     题目描述    给定一个数字字符串，用最小次数的加法让字符串等于一个给定的目标数字。每次加法就是在字符串的某个位置插入一个加号。在里面要的所有加号都插入后，就像做普通加法那样来求值。      例如，考虑字符串“12”，做0次加法，我们得到数字12。如果插入1个加号，我们得到3，因此，这个例子中，最少用1次加法就得到数字3.      再举一例，考虑字符串“303”和目标数字6，最佳方法不是“3+0+3”。而是“3+03”。能这样做是因为1个数的前导0不会改变它的大小。      写一个程序来实现这个算法。      输入输出格式 输入格式： 第1行：1个字符串s(1&lt;=s的长度&lt;=40);      第2行：1个整数N(N&lt;=100000)。      输出格式： 第1行：1个整数K，表示最少的加法次数让S等N。如果怎么做都不能让S等于N，则输出-1      输入输出样例 输入样例#1:    输出样例#1：    4    最初印象: 可能是暴力呀,组合虽然有这么多种情况, 但这道题的数据比较小∑C(40,i)(i:0-&gt;39), i从小到大遍历,哪种情况满足就可以直接跳出了.   可是怎么找出组合呢? 找到了组合就可以StrToInt计算和了  但是转念一看题目”快速求和”, 这种方法可不快速, 是否有更好的方法?(暂且不论)  找组合用dfs吧,累计加号的个数  我突然发现长度似乎有点长, 但是根据整数不大于十万, 所以长度是可以控制的,太长的可以直接跳过了   举个例子  如字符串12345, 这里为了方便下标和数相同,实际上要区分的.  我们可以构造这样一个二维数组,元素Aij指的是字符串下标i-&gt;j的数, 如果这个数&gt;N(len &lt;= 6), 那么值为-1(不搜它)  so, 这个数组如下  1   12  123 1234 12345 -1  2   23  234  2345 -1  -1  3   34   345 -1  -1  -1  4    45 -1  -1  -1  -1   5   构造出这样一个数组之后我们就可以进行dfs了, 不难发现从第一层开始, 找到一个数Ai,j, 那么下一个数要在j+1层里面去找,直到个数达到k(有两种情况)或者达不到k   答案呼之欲出.   代码初稿没过, 直接输出-1.  找到几个错误:   if(~ans) 代表的是如果ans不为-1, 但是我需要的是如果ans为-1. cnt刚开始传进去是0而不应该是1.  数组传递参数的时候传错了, i, j位置反了    结果90分, 还差10分是哪里出了问题? 可能是某个特殊情况吧.那就自己找几个特殊情况测试一下.  不用一个加号的.(没问题呀?)   不不不, 这个根据我之前的思路是有陷阱的.   一个区间长度可能很长, 但是前面可以有很多0, 那么这个应该算进去.   AC了, 就是这样. 不过我的代码有点取巧的意味, 还没有修改完全正确, 不过不管了,思路就是这样了.   完整代码    #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std;  int n, array[41][41], len, ans = -1; vector&lt;int&gt; node;  int str_to_int(string str, int i, int j) {     int val = 0;     for (int k = i; k &lt;= j; ++k)         val = val * 10 + str[k] - '0';     return val; }  void dfs(int i, int j, int k, int cnt, int sum) {     if (array[i][j] == -1) return;     sum += array[i][j];     if (cnt == k) {         if (sum == n &amp;&amp; j == len - 1) {             ans = cnt;             /*for (int i = 0; i &lt; node.size(); ++i) {                 cout &lt;&lt; node[i] &lt;&lt; ' ';             }             cout &lt;&lt; endl;*/         }         return;     }     for (int l = j + 1; l &lt; len; ++l) {         node.push_back(array[j + 1][l]);         dfs(j + 1, l, k, cnt + 1, sum);         node.pop_back();     } }   int main() {     string str;     cin &gt;&gt; str &gt;&gt; n;     memset(array, -1, sizeof(array));     len = str.size();     for (int i = 0; i &lt; len; ++i) {         for (int j = 0; j &lt; len; ++j) {             if (j &lt; i) continue;             if (j - i &gt;= 9) continue;             array[i][j] = str_to_int(str, i, j);         }     }     /*for (int i = 0; i &lt; len; ++i) {         for (int j = 0; j &lt; len; ++j) {             cout &lt;&lt; array[i][j] &lt;&lt; ' ';          }         cout &lt;&lt; endl;     }*/     if (n == str_to_int(str, 0, len - 1)) {         cout &lt;&lt; 0;         return 0;     }      for (int k = 1; k &lt; len; ++k) {         for (int i = 0; i &lt; len; ++i) {             if (!~ans) {                 node.push_back(array[0][i]);                 dfs(0, i, k, 0, 0);                 node.pop_back();             }         }     }     cout &lt;&lt; ans; }                                            