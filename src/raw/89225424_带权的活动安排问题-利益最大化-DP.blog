                                                                                                                                                         基础的贪心问题-活动安排问题是这种问题的特殊情况（权值为1）。但这个问题不能用贪心算法而是应该用动态规划算法来求解。这种问题下的另一种较特殊情况是每段任务的权值是它的时间长度，使活动安排时间最满，同样要用到动态规划算法。 思路是：先将活动按照结束时间排序（和贪心类似），然后从第一个活动开始遍历这些任务，同时维护一个全局最大值，到每个活动结束的最大值。排序时间复杂度为O(nlogn)，后面一段时间复杂度为O(n)。 状态转移方程为 Ans = max(Ans, last + edges[i].val); 其中，Ans为全局最大值，last为截止到上一个和本任务不产生冲突的任务所保存的最大值。有几个边界条件需要注意。 代码（没有测过大量数据，不知道有没有bug，不过大方向应该是对的） #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;  struct Edge {  int x, y, val, ans; };  bool cmp(Edge a, Edge b) {  return a.y &lt; b.y; }  int main() {  int n;  cin &gt;&gt; n;  Edge *edges = new Edge[n];  for (int i = 0; i &lt; n; ++i) {   cin &gt;&gt; edges[i].x &gt;&gt; edges[i].y &gt;&gt; edges[i].val;  }  sort(edges, edges + n, cmp);  int Ans = 0;  for (int i = 0; i &lt; n; ++i) { //  cout &lt;&lt; "now : " &lt;&lt; edges[i].x &lt;&lt; ' ' &lt;&lt; edges[i].y &lt;&lt; ' ' &lt;&lt; edges[i].val &lt;&lt; endl;   int last = 0;   for (int j = i - 1; j &gt;= 0; j--) {    if (edges[i].x &gt;= edges[j].y) { // 假定边界是可以重合的      last = edges[i].ans; //    cout &lt;&lt; "last = " &lt;&lt; last &lt;&lt; endl; //    cout &lt;&lt; edges[i].val &lt;&lt; endl;     Ans = max(Ans, last + edges[i].val);     break;    }    if (j == 0) Ans = max(Ans, last + edges[i].val); // 作为它的边界    }   if (i == 0) Ans = max(Ans, last + edges[i].val); // 第一个数据，直接设为边界    edges[i].ans = Ans;   cout &lt;&lt; "Now the ans = " &lt;&lt; Ans &lt;&lt; endl;  }  cout &lt;&lt; "The end ans = " &lt;&lt; Ans &lt;&lt; endl; } /* 3 1 4 2 7 10 3 2 6 8 */                                               