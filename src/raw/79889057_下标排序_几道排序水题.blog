                                                                                                                                                         之前没有想过不用结构体数组如何对一个有多种属性的变量体排序. 比如一个人, 既有名字又有分数, 先按照分数排序, 分数相同再按照名字排序, 然后输出序列.  一个非常简单明了的思路是, 用STL的sort, 自定义排序规则, 开一个结构体, 然后给结构体数组排序.  可是, 如果我不会结构体呢? 好像有点困难. 以前从没想过这样的问题, 今天看到有一位大佬用了下标排序的方法, 恍然大悟, 感觉非常奇妙.  这是一种非常有启迪的思想.  简单的代码:  #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int a[101] = {};  bool cmp(int x, int y) {     return a[x] &gt; a[y]; }  int main() {     int n, b[101] = {};     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; a[b[i] = i];     }     sort(b, b+n, cmp);     for(int i = 0; i &lt; n; ++i) {         cout &lt;&lt; a[b[i]] &lt;&lt; endl;     } }  下面是几道排序方面的水题.  P1177 【模板】快速排序  AC Code:  #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;  void quickSort(int *a, int left, int right) {     if(right &lt; left) return;     int key = a[(left+right)&gt;&gt;1], l = left, r = right;     do {         while(a[l] &lt; key) l++;         while(a[r] &gt; key) r--;         if(l &lt;= r) {             swap(a[l], a[r]);             l++, r--;         }     } while(l &lt;= r);     if(l &lt; right) quickSort(a, l, right);     if(r &gt; left) quickSort(a, left, r); }  int main() {     std::ios::sync_with_stdio(false);     int n;     cin &gt;&gt; n;     int *a = new int [n+1];     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; a[i];     }     quickSort(a, 0, n - 1);     for(int i = 0; i &lt; n; ++i) {         cout &lt;&lt; a[i] &lt;&lt; ' ';     } }  明明的随机数  AC Code:    #include &lt;iostream&gt; using namespace std;  int main() {     int n, a[1005] = {}, tmp, cnt = 0;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; tmp;         if(a[tmp]) cnt += 1;         a[tmp] = 1;     }     cout &lt;&lt; n - cnt &lt;&lt; endl;     for(int i = 0; i &lt; 1001; ++i) {         if(a[i]) cout &lt;&lt; i &lt;&lt; ' ';    } }  分数线划定  AC Code:    #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;  struct Stu {     string id;     int sco; }stu[10000];  bool cmp(Stu s1, Stu s2) {     if(s1.sco != s2.sco) {         return s1.sco &gt; s2.sco;     } else {         return s1.id &lt; s2.id;     } }  int main() {     int n, m;     cin &gt;&gt; n &gt;&gt; m;     int k = m*1.5;     for(int i = 1; i &lt;= n; ++i) {         cin &gt;&gt; stu[i].id &gt;&gt; stu[i].sco;     }     sort(stu+1, stu + n + 1, cmp);     int cnt = 0;     for(int i = k + 1; i &lt;= n; ++i) {         if(stu[i].sco == stu[k].sco) {             cnt++;         }     }     k += cnt;     cout &lt;&lt; stu[k].sco &lt;&lt; ' ' &lt;&lt; k &lt;&lt; endl;     for(int i = 1; i &lt;= k; ++i) {         cout &lt;&lt; stu[i].id &lt;&lt; ' ' &lt;&lt; stu[i].sco &lt;&lt; endl;     } }  宇宙总统  AC Code:    #include &lt;iostream&gt; #include &lt;stdlib.h&gt;  using namespace std;  struct Pre {     int id;     string ps; }pre[22];  bool MAX(string s1, string s2) {     if(s1.size() == s2.size()) {         return s1 &lt; s2;     } else {         return s1.size() &lt; s2.size();     } }  int main() {     int n;     cin &gt;&gt; n;     for(int i = 0; i &lt; n; ++i) {         cin &gt;&gt; pre[i+1].ps;         pre[i+1].id = i+1;     }     int id = 1;     string Max = "";     for(int j = 1; j &lt;= n; ++j) {         if(MAX(Max, pre[j].ps)) {             id = pre[j].id;             Max = pre[j].ps;         }     }     cout &lt;&lt; id &lt;&lt; endl &lt;&lt; Max; }                                            