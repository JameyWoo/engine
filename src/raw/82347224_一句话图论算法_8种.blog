                                                                                                                                                              一句话Dijkstra算法 一句话SPFA算法 一句话Kruskal算法 一句话Prim算法 一句话Tarjan算法 一句话Euler回路算法 一句话floyd算法 一句话DAG最长路算法           一句话Dijkstra算法  从源点开始更新邻边，遍历到达其最近的点，以其作为新源点，重复操作直到所有点更新完毕。  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int to, val;     Node (int t, int v) : to(t), val(v) {} };  const int maxn = 10005;  int n, m; vector&lt;Node&gt; G[maxn]; int vis[maxn] = {}, dis[maxn];  void Dijkstra() {     dis[1] = 0;     for (int i = 1; i &lt;= n; ++i) {         int u = -1, _min = 0x3f3f3f3f;         for (int j = 1; j &lt;= n; ++j) {             if (!vis[j] &amp;&amp; _min &gt; dis[j]) {                 _min = dis[j];                 u = j;             }         }         if (u == -1) break;         vis[u] = true;         for (int j = 0; j &lt; G[u].size(); ++j) {             int v = G[u][j].to, d = G[u][j].val;             dis[v] = min(dis[v], dis[u] + d);         }     } }  int main() {     cin &gt;&gt; n &gt;&gt; m;     for (int i = 1; i &lt;= n; ++i)         dis[i] = 0x3f3f3f3f;     for (int i = 0; i &lt; m; ++i) {         int from, to, val;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;         G[from].push_back(Node(to, val));         G[to].push_back(Node(from, val));     }     Dijkstra();     for (int i = 1; i &lt;= n; ++i)         cout &lt;&lt; dis[i] &lt;&lt; ' '; }  一句话SPFA算法  一条边当且仅当有和他相连的边更新后它才会更新，使用队列不断找出这样的边，直到无法找出  #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int to, val;     Node (int t, int v): to(t), val(v) {} };  const int maxn = 10005; const int INF = 0x3f3f3f3f;  int n, m; vector&lt;Node&gt; G[maxn]; int dis[maxn]; bool inq[maxn] = {};  void SPFA() {     dis[1] = 0;     queue&lt;int&gt; Q;     Q.push(1);     inq[1] = true;     while (!Q.empty()) {         int now = Q.front();         Q.pop();         inq[now] = false;         for (int i = 0; i &lt; G[now].size(); ++i) {             int u = now;             int v = G[now][i].to, d = G[now][i].val;             if (dis[v] &gt; dis[u] + d) {                 dis[v] = dis[u] + d;                 if (!inq[v]) {                     Q.push(v);                     inq[v] = true;                 }             }         }     } }  int main() {     memset(dis, 0x3f, sizeof(dis));     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt; m; ++i) {         int from, to, val;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;         G[from].push_back(Node(to, val));         G[to].push_back(Node(from, val));     }     SPFA();     for (int i = 1; i &lt;= n; ++i)         cout &lt;&lt; dis[i] &lt;&lt; ' '; }  一句话Kruskal算法  给边按权值从小到大排序，依次找出使边不成环的所有边，所构成图即为最小生成树。  #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;  struct Edge {     int from, to, cost;     Edge (int f, int t, int c): from(f), to(t), cost(c) {} };  const int maxn = 10005; const int INF = 0x3f3f3f3f;  int n, m; vector&lt;Edge&gt; edge; vector&lt;int&gt; ans; int father[maxn];  bool cmp(Edge x, Edge y) {     return x.cost &lt; y.cost; }  void init() {     for (int i = 1; i &lt;= n; ++i)         father[i] = i; }  int find(int x) {     return x == father[x] ? x : father[x] = find(father[x]); }  void Kruskal() {     sort(edge.begin(), edge.end(), cmp);     for (size_t i = 0; i &lt; edge.size(); ++i) {         int x = find(edge[i].from), y = find(edge[i].to);         if (x != y) {             father[x] = y;             ans.push_back(edge[i].cost);         }     } }  int main() {     cin &gt;&gt; n &gt;&gt; m;     init();     for (int i = 0; i &lt; m; ++i) {         int from, to, cost;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;         edge.push_back(Edge(from, to, cost));     }     Kruskal();     for (int i = 0; i &lt; ans.size(); ++i)         cout &lt;&lt; ans[i] &lt;&lt; ' '; }    一句话Prim算法  类似Dijkstra算法，从源点出发，更新其邻边所连点，找到最短距离点，加入点集作为源点集，重复步骤直到所有点添加完毕  #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int to, cost;     Node (int t, int c) : to(t), cost(c) {} };  const int maxn = 10005; const int INF = 0x3f3f3f3f;  int n, m; int dis[maxn] = {}; bool vis[maxn] = {}; vector&lt;Node&gt; G[maxn]; vector&lt;int&gt; ans;  void Prim() {     dis[1] = 0;     for (int i = 1; i &lt;= n; ++i) {         int u = -1, _min = 0x3f3f3f3f;         for (int j = 1; j &lt;= n; ++j) {             if (!vis[j] &amp;&amp; dis[j] &lt; _min) {                 _min = dis[j];                 u = j;             }         }         if (u == -1) break;         vis[u] = true;         ans.push_back(_min);         for (size_t j = 0; j &lt; G[u].size(); ++j) {             int v = G[u][j].to, d = G[u][j].cost;             dis[v] = min(dis[v], d);         }     } }  int main() {     cin &gt;&gt; n &gt;&gt; m;     memset(dis, 0x3f, sizeof(dis));     for (int i = 0; i &lt; m; ++i) {         int from, to, cost;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;         G[from].push_back(Node(to, cost));         G[to].push_back(Node(from, cost));     }     Prim();     for (size_t i = 1; i &lt; ans.size(); ++i)         cout &lt;&lt; ans[i] &lt;&lt; ' '; }  一句话Tarjan算法  新时间戳遇上了旧时间戳，就连成了环，dfn和low相同，则为环（或单点）的起点，维护dfn和low是要点。  tip：单向图  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std;  const int maxn = 10005; int n, m; bool ins[maxn] = {}; vector&lt;int&gt; G[maxn]; stack&lt;int&gt; S; int dfn[maxn] = {}, low[maxn]; int index = 0, ans = 0;  void tarjan(int u) {     S.push(u);     ins[u] = true;     dfn[u] = low[u] = ++index;     for (size_t i = 0; i &lt; G[u].size(); ++i) {         int v = G[u][i];         if (dfn[v] == 0) {             tarjan(v);             low[u] = min(low[u], low[v]);         } else if (ins[v]) low[u] = min(low[u], low[v]);     }     if (dfn[u] == low[u]) {         ans++;         int now;         do {             now = S.top();             S.pop();             ins[now] = false;             cout &lt;&lt; now &lt;&lt; ' ';         } while (now != u);         cout &lt;&lt; endl;     } }  int main() {     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt; m; ++i) {         int from, to;         cin &gt;&gt; from &gt;&gt; to;         G[from].push_back(to);  // 有向图     }     for (int i = 1; i &lt;= n; ++i) {         if (!dfn[i]) tarjan(i);     }     cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; endl; }  一句话Euler回路算法  断奇偶，一点出，栈结构，末尾入，走去边，倒着输。  #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std;  const int maxn = 1005; int n, m; bool G[maxn][maxn] = {}; stack&lt;int&gt; S;  void Euler(int u) {     cout &lt;&lt; "u = " &lt;&lt; u &lt;&lt; endl;     for (size_t i = 1; i &lt;= n; ++i) {         if (G[u][i]) {             G[u][i] = G[i][u] = false;             Euler(i);         }     }     S.push(u); }  int main() {     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt; m; ++i) {         int from, to;         cin &gt;&gt; from &gt;&gt; to;         G[from][to] = G[to][from] = true;     }     Euler(4);     while (!S.empty()) {         cout &lt;&lt; S.top() &lt;&lt; ' ';         S.pop();     } }  一句话floyd算法  遍历每个点作为中间结点，如果可以以此点更新两邻点，则更新。  #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std;  const int maxn = 1003; int n, m; int G[maxn][maxn] = {};  int main() {     memset(G, 0x3f, sizeof(G));     cin &gt;&gt; n &gt;&gt; m;     for (int i = 1; i &lt;= n; ++i)         G[i][i] = 0;     for (int i = 0; i &lt; m; ++i) {         int from, to, cost;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;         G[from][to] = G[to][from] = cost;     }     for (int k = 1; k &lt;= n; ++k) {         for (int i = 1; i &lt;= n; ++i) {             for (int j = 1; j &lt;= n; ++j) {                 G[i][j] = min(G[i][j], G[i][k] + G[k][j]);             }         }     }     for (int i = 1; i &lt;= n; ++i) {         for (int j = 1; j &lt;= n; ++j)             cout &lt;&lt; G[i][j] &lt;&lt; ' ';         cout &lt;&lt; endl;     } }  一句话DAG最长路算法  预知后事如何，请从前事算起，取最大值也。  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  const int maxn = 1005; int n, m; int G[maxn][maxn] = {}; int dis[maxn] = {};  int DAG(int u) {     if (dis[u]) return dis[u];     for (int i = 1; i &lt;= n; ++i) {         if (G[i][u]) {             dis[u] = max(dis[u], DAG(i) + G[i][u]);         }     }     return dis[u]; }  int main() {     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt; m; ++i) {         int from, to, cost;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;         G[from][to] = cost;     }     DAG(4);     for (int i = 1; i &lt;= 5; ++i) {         cout &lt;&lt; dis[i] &lt;&lt; ' ';     }     cout &lt;&lt; endl; }                                            