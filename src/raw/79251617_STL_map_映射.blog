                                                                                                                                                         构造一个map的方法是     map &lt; string, int&gt; m;    map &lt; int, string&gt; m;    map &lt; string, string&gt; m;   在&lt; &gt;中指定一对键(key)值(value)的类型.  在map中可以通过重载了的[]来通过键访问值  即     m[“a”] = 1;    m[“hello”] = 666;   map常用函数如下     size()　　　　　　//返回map中元素数    clear()　　　　　　//清空map    begin()　　　　　　//返回指向map开头的迭代器    end()　　　　　　//返回指向map末尾的迭代器    insert( (key, val) )　　　　　　//向map中擦汗如元素(key, val)    erase(key)　　　　　　//删除含有key的元素    find(key)　　　　　　//搜索与key一致的元素, 并返回指向该元素的迭代器.    　　　　　　　　　　　//没有与key一致的元素, 则返回末尾end()　   map和set一样通过平衡二叉搜索树实现, 因此元素的插入, 删除, 搜索以及”[ ]”运算符的复杂度都为O(logn)  使用迭代器顺序访问每一对键和值     map&lt; string, int&gt; :: iterator it = m.begin();    cout &lt;&lt; it-&gt;first &lt;&lt; endl; 　　　　　//print the key    cout &lt;&lt; it-&gt;second &lt;&lt; endl; 　　　　　//print the value   也可以使用STL提供的pair(结构体模板) 对map的元素进行访问  pair详细说明     pair&lt; string, int&gt; item = *it;    cout &lt;&lt; item.first; 　　　　　 //the key;    cout &lt;&lt; item.second; 　　　　　//the value    item = make_pair(“heo”, 23);   #include &lt;iostream&gt; #include &lt;map&gt;  using namespace std;  int main() {     map &lt;string, int&gt; m;     m["a"] = 97;     m["b"] = 98;     map &lt;string, int&gt; :: iterator it = m.begin();     cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl;  //print the key and the value     it++;     pair &lt;string, int&gt; item = *it;     cout &lt;&lt; item.first &lt;&lt; ' ' &lt;&lt; item.second &lt;&lt; endl; }  map的键值的唯一性怎么样?  test 1:  向一个已有(“a”, “A”)的map中再添加, map不变, 可知相同的元素是唯一的  test 2:  向一个有(“a”, “A”)的map中添加(“a”, “aa”), map还是不变, 这是为什么? 它内部检测是否唯一的机制难道是如果键存在, 那么这个insert就失效?  所以修改值的方法只能是用迭代器的方法直接修改  常用函数用法代码::  #include &lt;iostream&gt; #include &lt;map&gt;  using namespace std;  int main() {     //construct a map     map &lt; string, string &gt; alpha;      //the size     cout &lt;&lt; "the size is " &lt;&lt; alpha.size() &lt;&lt; endl;      //three ways to insert     alpha.insert(make_pair("a", "A"));     alpha.insert(pair&lt;string, string&gt;("b","B"));     pair&lt;string, string&gt; pp("c", "C");     alpha.insert(pp);      //cannot insert     alpha.insert(make_pair("a", "aa"));     cout &lt;&lt; "now the size is " &lt;&lt; alpha.size() &lt;&lt; endl;      //use the iterator to traversal     map &lt;string, string&gt; :: iterator it = alpha.begin();     while(it != alpha.end()) {         cout &lt;&lt; "the first is " &lt;&lt; it-&gt;first &lt;&lt; " and ";         cout &lt;&lt; "the second is " &lt;&lt; it-&gt;second &lt;&lt; endl;         it++;     }      //use the fuction of erase     alpha.erase("b");      //traversal again     it = alpha.begin();     cout &lt;&lt; endl;     while(it != alpha.end()) {         cout &lt;&lt; "the first is " &lt;&lt; it-&gt;first &lt;&lt; " and ";         cout &lt;&lt; "the second is " &lt;&lt; it-&gt;second &lt;&lt; endl;         it++;     }      //use find     if(alpha.find("b") == alpha.end()) {         cout &lt;&lt; "there is no the key---\"b\"\n";     }     if(alpha.find("c") != alpha.end()) {         cout &lt;&lt; "yes, there is , and it is ";         cout &lt;&lt; alpha.find("c")-&gt;second &lt;&lt; endl;     } }                                            