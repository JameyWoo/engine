                                                                                                                                                         CCF 201412-3 集合竞价 传送门  2018-9-7日更新。谢谢一位同学的提示，已将所有int改为long long, 得了100分。  只得了80分, 硬是找不出bug在哪里.  思路是:   1. 对命令进行处理, 改取消的取消, 可以stringstream方便读取字符串中的string double int.  2. 将两种命令(sell和buy)分别按价格排序.  3.  同时向右查询, 以buy为循环外围, 对每个可更新答案的情况进行更新. 答案一定是buy的某个价格, 对每一个价格, 找它的尽可能成交量多的情况.  我估计我是步骤三有个bug  80分Code  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;vector&gt; using namespace std;  struct Node {     double money;     long long num;     Node (double m, long long n): money(m), num(n) {} };  bool cmp(Node x, Node y) {     return x.money &lt; y.money; }  string str[5005]; long long sum_buy[5005], sum_sell[5005];  int main() {     long long t = 0;     while (getline(cin, str[++t])) {         if (str[t][0] == 'c') {             long long in = 7, line = 0;             for (long long i = in; i &lt; str[t].size(); ++i) {                 line = line*10 + int(str[t][i] - '0');             }             str[line] = "";             str[t] = "";         }     }     vector&lt;Node&gt; sell, buy;     for (long long i = 1; i &lt;= t; ++i) {         stringstream sin(str[i]);         string tmp;         double money;         long long num;         sin &gt;&gt; tmp &gt;&gt; money &gt;&gt; num;         if (str[i][0] == 's') sell.push_back(Node(money, num));         else if (str[i][0] == 'b') buy.push_back(Node(money, num));     }     sort(buy.begin(), buy.end(), cmp);     sort(sell.begin(), sell.end(), cmp);     sum_buy[buy.size()] = 0;     for (long long i = buy.size() - 1; i &gt;= 0; --i)         sum_buy[i] = sum_buy[i + 1] + buy[i].num;     sum_sell[0] = sell[0].num;     for (long long i = 1; i &lt; sell.size(); ++i)         sum_sell[i] = sum_sell[i - 1] + sell[i].num;     double ans_mny = 0;     long long ans_cnt = 0;     for (long long i = 0, j = 0; i &lt; buy.size(); ++i) {         double bmo = buy[i].money;         while (sell[j].money &lt;= bmo) {             if (j == sell.size() - 1 || sell[j+1].money &gt; bmo) {                 if (ans_cnt &lt;= min(sum_buy[i], sum_sell[j])) {                     ans_cnt = min(sum_buy[i], sum_sell[j]);                     ans_mny = bmo;                 }                 break;             }             j++;         }     }     printf("%.2lf %lld", ans_mny, ans_cnt); }                                            