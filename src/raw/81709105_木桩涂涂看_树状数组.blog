                                                                                                                                                         习题：木桩涂涂看                       n" role="presentation">nnn 个木桩排成一排，从左到右依次编号为 1,2,3...n" role="presentation">1,2,3...n1,2,3...n1, 2, 3...n。每次给定 2" role="presentation">222 个整数 a" role="presentation">aaa，b" role="presentation">bbb（a&amp;#x2264;b" role="presentation">a≤ba≤ba \leq b），蒜头君便骑上他的电动车从木桩 a" role="presentation">aaa 开始到木桩 b" role="presentation">bbb 依次给每个木桩涂一次颜色。但是 n" role="presentation">nnn 次以后 lele 已经忘记了第 i" role="presentation">iii 个木桩已经涂过几次颜色了，你能帮他算出每个木桩被涂过几次颜色吗？输入格式第一行是一个整数 n" role="presentation">nnn（n&amp;#x2264;100000" role="presentation">n≤100000n≤100000n \leq 100000）。接下来的 n" role="presentation">nnn 行，每行包括两个整数 a, b (1&amp;#x2264;a&amp;#x2264;b&amp;#x2264;n" role="presentation">1≤a≤b≤n1≤a≤b≤n1 \leq a \leq b \leq n)。输出格式n" role="presentation">nnn 个整数，第 i" role="presentation">iii 个数代表第 i" role="presentation">iii 个木桩总共被涂色的次数。                                                                                                                                                样例输入                         3 1 1 1 2 1 3                                               样例输出                         3 2 1   看了这位仁兄的博客, 代码非常巧妙精彩, 不过我没看懂.  然后这位仁兄的博客让我知道了为什么, 十分感谢.  这是一个点被多少个区间覆盖的问题, 结果就是求“这个点及它前面的左端点”减去”它前面的右端点”.  这似乎是差分的思想. 树状数组最基本的作用是单点修改区间查询, 而利用差分可以做到区间修改单点查询.  代码1  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  const int maxn = 100005; int C1[maxn] = {}, C2[maxn] = {}; int n;  void update(int x, int y) {     while (x &lt;= n) {         C1[x]++;         x += (x &amp; -x);     }     while (y &lt;= n) {         C2[y]++;         y += (y &amp; -y);     } }  int getSum(int x) {     int sum1 = 0, sum2 = 0, tmp = x;     while (tmp &gt;= 1) {         sum1 += C1[tmp];         tmp -= (tmp &amp; -tmp);     }     tmp = x - 1;     while (tmp &gt;= 1) {         sum2 += C2[tmp];         tmp -= (tmp &amp; -tmp);     }     return sum1 - sum2; }  int main() {     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         int x, y;         cin &gt;&gt; x &gt;&gt; y;         update(x, y);     }     for (int i = 1; i &lt;= n; ++i) {         cout &lt;&lt; getSum(i) &lt;&lt; (i == n ? "":" ");     } }  代码2: 树状数组+差分    #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  int n, C[100005] = {};  void update(int x, int val) {     for (; x &lt;= n; x += (x &amp; -x)) {         C[x] += val;     } }  int getSum(int x) {     int sum = 0;     for (; x &gt;= 1; x -= (x &amp; -x)) {         sum += C[x];     }     return sum; }  int main() {     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         int x, y;         cin &gt;&gt; x &gt;&gt; y;         update(x, 1);         update(y + 1, -1);     }     for (int i = 1; i &lt;= n; ++i) {         cout &lt;&lt; getSum(i) &lt;&lt; (i == n ? "":" ");     } }                                            