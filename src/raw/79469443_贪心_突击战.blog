                                                                                                                                                         &lt;&lt;算法竞赛入门经典-训练指南&gt;&gt;第二题.  也是一道贪心题目. 就如书上分析所说, 直觉告诉我们, 这道题用贪心.  书上一个我不曾了解的知识点:     向vector v中压入一个Job(自定义结构体)变量    v.push_back((Job){a, b});   原Job    struct Job { int a, b; };  似乎不用写构造函数就可以构造一个Job变量.  想了想之前忘得差不多的类的知识, 写了个构造, 所以以下这样也可以  struct Job {  //这是结构体     int a, b;     Job(int a, int b) : a(a), b(b){} };    v.push_back(Job(a, b));  //这是压入操作  pair, make_pair什么的给忘掉了……  等会补回来  一下完整代码  #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  struct Job {     int a, b;     Job(int a, int b) : a(a), b(b){} };  bool cmp(Job a, Job b) {     return a.b &gt; b.b; }  int main() {     using namespace std;     int n, cnt = 0;     while(scanf("%d", &amp;n) == 1 &amp;&amp; n) {         vector &lt;Job&gt; v;         int a, b;         for(int i = 0; i &lt; n; ++i) {             scanf("%d %d", &amp;a, &amp;b);             v.push_back(Job(a, b));         }         sort(v.begin(), v.end(), cmp);         int ans = 0, now = 0;         for(int i = 0; i &lt; n; ++i) {             now += v[i].a;             ans = max(ans, now + v[i].b);         }         printf("Case %d : %d\n", ++cnt, ans);      } }  /* 3 2 5 3 2 2 1 3 3 3 4 4 5 5 0 */                                             