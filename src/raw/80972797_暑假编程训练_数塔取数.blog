                                                                                                                                                         数塔取数  这是一道入门的动态规划题, 没做过的可能很难想出, 但是做过的会觉得很简单.   这道题相比最基础的数塔取数多了一个求路径. 只要记录所继承的下一层数的下标. 最后从头开始走过这些下标就是路径了.   时间复杂度是O(n), n为数塔的数的个数.    #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std;  const int maxn = 1005; int n, sum[maxn][maxn];  struct T {     int x, y; } arr[maxn][maxn];  int main() {     memset(sum, 0, sizeof(sum));     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         for (int j = 1; j &lt;= i; ++j) {             cin &gt;&gt; arr[i][j].x;         }     }     for (int i = 1; i &lt;= n; ++i) {         arr[n][i].y = i;         sum[n][i] = arr[n][i].x;     }      for (int i = n - 1; i &gt;= 1; --i) {         for (int j = 1; j &lt;= i; ++j) {             if (sum[i + 1][j] &gt; sum[i + 1][j + 1]) {                 sum[i][j] = sum[i + 1][j] + arr[i][j].x;                 arr[i][j].y = j;             } else {                 sum[i][j] = sum[i + 1][j + 1] + arr[i][j].x;                 arr[i][j].y = j + 1;             }         }     }      /*for (int i = 1; i &lt;= n; ++i) {         for (int j = 1; j &lt;= i; ++j) {             cout &lt;&lt; sum[i][j] &lt;&lt; ' ';         }         cout &lt;&lt; endl;     }*/      cout &lt;&lt; sum[1][1] &lt;&lt; '\n';      int k = 1, next = 1;     while (k &lt;= n) {         cout &lt;&lt; arr[k][next].x &lt;&lt; ' ';         next = arr[k++][next].y;     }     cout &lt;&lt; endl; }  /* 5  9 12 15 10 6 8 2 18 9 5 19 7 10 4 16 */                                            