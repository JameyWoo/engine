                                                                                                                                                         今天找了篇文章学习了一下pycuda，发现过程其实和Cuda C差不多，而且代码里面还要用到Cuda C，感觉就是用了python的外壳，整理好了数据，然后传递给编写好的Cuda C，编译器编译即可。 开始时遇到了一个问题，在解释下面这段代码时，出现这样的提示 nvcc fatal : Cannot find compiler 'cl.exe' in PATH although Visual Studio 12.0 is added to PATH mod = SourceModule("""  __global__ void doublify(float *a)  {  int idx = threadIdx.x + threadIdx.y*4;  a[idx] *= 2;  }  """)  在谷歌一下解决方法后，得到解决的方法是将cl.exe文件添加到环境变量中。在我的VS版本里这个程序的路径是C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64，开始添加到系统环境变量里面总是失败，在powershell上还是找不到，经过多次尝试和重启之后终于添加成功。虽然还是不知道之前几次为什么没有添加成功，但是现在最开始的问题已经得到了解决。  教程文章地址 源代码如下 #!/usr/bin/env python # coding: utf-8  # In[1]:   import pycuda.driver as cuda import pycuda.autoinit from pycuda.compiler import SourceModule   # In[2]:   import numpy a = numpy.random.randn(4, 4)   # In[3]:   a = a.astype(numpy.float32)   # In[4]:   a_gpu = cuda.mem_alloc(a.nbytes) cuda.memcpy_htod(a_gpu, a)   # In[5]:   mod = SourceModule(""" __global__ void doublify(float *a_gpu) {     int idx = threadIdx.x + threadIdx.y*4;     a_gpu[idx] *= 2; } """)   # In[6]:   func = mod.get_function("doublify") func(a_gpu, block=(4,4,1))   # In[7]:   a_doubled = numpy.empty_like(a) cuda.memcpy_dtoh(a_doubled, a_gpu) print (a_doubled) print (a)                                                