                                                                                                                                                         STL中有支持排序和检索的函数如sort, 二分查找. 使用起来较为方便.    sort函数  添加在头文件algorithm中, 使用方法如:  sort(start,end[,排序方法])    int a[5] = {1,2,34,4,3}; sort(a, a+5);  //这是最简单的sort方法, 使用默认的排序方法升序排列  sort(a, a+5, cmp); // cmp为bool函数名, 是自定义规则比较函数  //自定义的cmp函数 bool cmp(int a, int b) {     return a &gt; b; }    binary_search()  STL提供的一种bool二分搜索函数, 使用方式为:     binary_search(start, end, argu);    if (binary_search(a, a+5, 3)){ }   返回true或false    lower_bound()  返回第一个大于或等于x的第一个位置  使用方法为:     lower_bound(start, end, x);  //返回的是指针   一般这样:     int a[5] = {1,2,3,4,5};    int p = lower_bound(a, a+5, x) - a;    cout &lt;&lt; a[p];  //p的值对应数组a的下标     upper_bound()  返回第一个大于x的第一个位置  使用方法为:     upper_bound(start, end, x);  //返回的是指针   一般这样:     int a[5] = {1,2,3,4,5};    int p = upper_bound(a, a+5, x) - a;    cout &lt;&lt; a[p];  //p的值对应数组a的下标   参考书目见紫书P108, 以及网上各博客    更新, 在实践中发现了一些上面没有的问题  普通的二分查找函数是对升序的序列进行查找的, 也就是对一个降序序列查找是错误的, 那么这些函数和sort类似, 就应该添加一个方法函数, 如:    bool cmp(int a, int b) {     return a &gt; b; } binary_search(a, a+1000, 33, cmp);  其他函数类似.  一个综合的应用如下    #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt;  using namespace std;  bool cmp(int a, int b) {     return a &gt; b; }  int main() {     srand(time(NULL));     int a[1000] = {};     for( int i = 0; i &lt; 1000; ++i ) {         a[i] = rand()%1000;     }     cout &lt;&lt; "sizeof a / int: " &lt;&lt; sizeof(a)/sizeof(int) &lt;&lt; endl;      sort(a, a+1000);     for( int i = 0; i &lt; 1000; ++i ) {         //cout &lt;&lt; a[i] &lt;&lt; endl;     }     if(binary_search(a, a+1000, 555)){         cout &lt;&lt; "yes ! there is 555\n";     }      sort(a, a+1000, cmp);     for( int i = 0; i &lt; 1000; ++i ) {         //cout &lt;&lt; a[i] &lt;&lt; endl;     }     if(binary_search(a, a+1000, 555, cmp)){         cout &lt;&lt; "yes ! there is 555\n";     }      int p = lower_bound(a, a+1000, 345, cmp) - a;     cout &lt;&lt; "a[p] == " &lt;&lt; a[p] &lt;&lt; endl;      p = upper_bound(a, a+1000, 345, cmp) - a;     cout &lt;&lt; "a[p] == " &lt;&lt; a[p] &lt;&lt; endl; }  输出结果为     sizeof a / int: 1000    yes ! there is 555    yes ! there is 555    a[p] == 345    a[p] == 344                                             