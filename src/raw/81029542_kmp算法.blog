                                                                                                                                                            前言 1. next数组的求解 2.最基本kmp算法的实现 3.计算匹配的次数 4.next数组的优化, 实现更快速的匹配       前言  kmp算法全名叫做Knuth-Morris-Pratt算法, 是一种字符串匹配算法.  给出两个字符串序列text和pattern.  有以下循序渐进的四个问题  1. 对next数组的理解  2. 判断pattern串是否是text的子串  3.  判断pattern串在text中出现的次数  4.  next数组的优化, 从而实现更加快速的匹配  1. next数组的求解  void getNext(string s) {     int j = next[0] = -1;     int len = s.size();     for (int i = 1; i &lt; len; ++i) { // 从1开始, 因为只有一个字符的时候无法匹配          while (j != -1 &amp;&amp; s[i] != s[j + 1]) {             j = next[j];         }         if (s[i] == s[j + 1]) j++;         next[i] = j;     }     for (int i = 0; i &lt; len; ++i) {         cout &lt;&lt; next[i] &lt;&lt; ' ';     }     cout &lt;&lt; endl; }    2.最基本kmp算法的实现  #include &lt;iostream&gt; using namespace std;  int next[1005] = {-1};  void getNext(string s) {     int j = -1, len = s.size();     for (int i = 1; i &lt; len; ++i) {         while (j != -1 &amp;&amp; s[i] != s[j + 1]) {             j = next[j];         }         if (s[i] == s[j + 1]) j++;         next[j] = j;     } }  bool kmp(string text, string pattern) {     int j = -1, len = text.size(), len_p = pattern.size();     getNext(pattern);     for (int i = 0; i &lt; len; ++i) {         while (j != -1 &amp;&amp; text[i] != pattern[j + 1]) {             j = next[j];         }         if (text[i] == pattern[j + 1]) j++;         if (j == len_p - 1) return true;     }     return false; }  int main() {     string pattern, text;     cin &gt;&gt; text &gt;&gt; pattern;     if (kmp(text, pattern)) {         cout &lt;&lt; pattern &lt;&lt; " 是 " &lt;&lt; text &lt;&lt; " 的一个子串\n";      } else cout &lt;&lt; pattern &lt;&lt; " 不是 " &lt;&lt; text &lt;&lt; " 的一个子串\n";  } /* iamsorrybutithinkyoushouldthinkaboutyourselftoo but */    3.计算匹配的次数  只要稍微修改一下匹配到模式串时的程序就可. j 回退到 next[j].  // 记录匹配模式串的次数  #include &lt;iostream&gt; using namespace std;  int next[1005] = {-1}, ans = 0;  void getNext(string s) {     int j = -1, len = s.size();     for (int i = 1; i &lt; len; ++i) {         while (j != -1 &amp;&amp; s[i] != s[j + 1]) {             j = next[j];         }         if (s[i] == s[j + 1]) j++;         next[j] = j;     } }  void kmp(string text, string pattern) {     int j = -1, len = text.size(), len_p = pattern.size();     getNext(pattern);     for (int i = 0; i &lt; len; ++i) {         while (j != -1 &amp;&amp; text[i] != pattern[j + 1]) {             j = next[j];         }         if (text[i] == pattern[j + 1]) j++;         if (j == len_p - 1) {             ans++;             j = next[j];         }     } }  int main() {     string pattern, text;     cin &gt;&gt; text &gt;&gt; pattern;     kmp(text, pattern);     cout &lt;&lt; "模式串在文本串中出现了 " &lt;&lt; ans &lt;&lt; " 次" &lt;&lt; endl; } /* iamsorrybutithinkyoushouldthinkaboutyourselftoo but */    4.next数组的优化, 实现更快速的匹配  void getNextval(string s) // 优化 {     int j = -1, len = s.size();     for (int i = 1; i &lt; len; ++i) {         while (j != -1 &amp;&amp; s[i] != s[j + 1]) {             j = next[j];         }         if (s[i] == s[j + 1]) j++;         if (j == -1 || s[i] != s[j + 1]) { // 之所以用条件而非循环是因为在处理这一步之前所有的都处理过了一次              next[i] = j;         } else next[i] = next[j];     } }                                            