                                                                                                                                                         CCF 201503-5 最小花费 传送门  毕竟是个蒟蒻, 所以这CCF-CSP第五题也只能用用O(nm)的算法暴力去解了, 而且常数还TM很大. 得了30分, 也算是出题人放了个小水.  思路就是:  用DFS找到两端点的路径, 同时存储边的长度. O(n)  对每一条路径点判断物价大小,维持当前最小的物价,购买尽可能多的粮食直到可以走到更小的物价处  注意用long long, 不然你只能得个10分咧  看大佬的满分代码. 点俺点俺  好歹是第五题, 贴出30分代码也不丢人是不  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std;  struct Node {     long long from, to, cost;     Node (long long f, long long t, long long c) : from(f), to(t), cost(c) {} };  const long long maxn = 100000 + 5; long long n, m, cost[maxn]; vector&lt;Node&gt; G[maxn]; vector&lt;long long&gt; Path, path, Dis, dis; // 真假path bool vis[maxn];  void DFS(long long from, long long to) {     if (from == to) {         Path = path;         Dis = dis;         return;     }     for (long long i = 0, v, d; i &lt; G[from].size(); ++i) {         v = G[from][i].to;         d = G[from][i].cost;         if (vis[v]) continue;         vis[v] = true;         path.push_back(v);         dis.push_back(d);         DFS(v, to);         path.pop_back();         dis.pop_back();     } }  int main() {     ios::sync_with_stdio(false);     cin &gt;&gt; n &gt;&gt; m;     for (long long i = 1; i &lt;= n; ++i)         cin &gt;&gt; cost[i];     for (long long i = 1, u, v, c; i &lt; n; ++i) {         cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;         G[u].push_back(Node(u, v, c));         G[v].push_back(Node(v, u, c));     }     for (long long i = 0, from, to; i &lt; m; ++i) {         cin &gt;&gt; from &gt;&gt; to;         memset(vis, 0, sizeof(vis));         path.clear();         dis.clear();         path.push_back(from);         vis[from] = true;         DFS(from, to);         long long _min = cost[from], cos = 0, ans = 0;         for (long long i = 0; i &lt; Path.size() - 1; ++i) {             if (cost[Path[i]] &lt; _min) {                 ans += cos*_min;                 cos = 0;                 _min = cost[Path[i]];             }             cos += Dis[i];         }         ans += _min*cos;         cout &lt;&lt; ans &lt;&lt; endl;     } }                                            