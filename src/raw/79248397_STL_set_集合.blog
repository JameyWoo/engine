                                                                                                                                                         ——————2018-4-14更新———————  set中判定一个元素是否存在除了用find, 还可以用count()函数  如果存在, 返回一, 如果不存在, 返回0. (元素的数量)    set的排序规则, 使用cmp结构体  #include &lt;iostream&gt; #include &lt;set&gt; using namespace std;  struct cmp {     bool operator () (int x, int y) {         return x &gt; y;     } };  struct comp {     bool operator () (string x, string y) {         if(x.size() == y.size()) return x &lt; y;         else return x.size() &lt; y.size();     } };  int main() {     set&lt;int, cmp&gt; s;     for(int i = 0; i &lt; 10; ++i) {         s.insert(i);     }     set&lt;int, cmp&gt;::iterator it = s.begin();     while(it != s.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it++;     }     cout &lt;&lt; endl;      set&lt;string, comp&gt; str;     str.insert("abc");     str.insert("gh");     str.insert("fhlsd");     str.insert("z");     set&lt;string, cmp&gt;::iterator is = str.begin();     while(is != str.end()) {         cout &lt;&lt; *is &lt;&lt; ' ';         is++;     }     cout &lt;&lt; endl; }  erase()函数使用  有三种传递参数的方法    set中的交集, 并集, 差集, 对称差  使用方法全在下面代码  虽然参数有点多, 有点烦, 但仔细想想, 正是这么多这么细的参数, 才好实现这些函数的功能, 才能跟灵活的使用集合的运算  需要注意的是, 这些函数是包含在算法库里面的, 之前还以为就在set里面呢.    #include &lt;set&gt;  #include &lt;algorithm&gt;  //注意, 这些函数是在算法库里的  #include &lt;iostream&gt; using namespace std;  int main() {     set&lt;int&gt; s1, s2, s3, s4, s5, s6, s7;     for(int i = 0; i &lt; 10; ++i) {         s1.insert(i);     }     for(int j = 7; j &lt; 16; ++j) {         s2.insert(j);     }      //交集      set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s3, s3.begin()));     set&lt;int&gt;::iterator it = s3.begin();     while(it != s3.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it ++;     }      cout &lt;&lt; endl;      //并集      set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s4, s4.begin()));      it = s4.begin();     while(it != s4.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it ++;     }      cout &lt;&lt; endl;      //差集1     set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s5, s5.begin()));      it = s5.begin();     while(it != s5.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it ++;     }      cout &lt;&lt; endl;      //差集2     set_difference(s2.begin(), s2.end(), s1.begin(), s1.end(), inserter(s6, s6.begin()));      it = s6.begin();     while(it != s6.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it ++;     }      cout &lt;&lt; endl;      //对称差     set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s7, s7.begin()));      it = s7.begin();     while(it != s7.end()) {         cout &lt;&lt; *it &lt;&lt; ' ';         it++;     }     cout &lt;&lt; endl; }  ——————以上是更新————————–    set是C++STL中常用的容器, 意思是集合  和数学中的集合一样, 它的每一个元素都是唯一的, 即不存在相同的元素  set里元素排列是有顺序的, 默认为升序排序  和sort一样, 排序的规则可以自定义  常用的函数有:  begin()     　　 返回set容器的第一个元素的地址  end() 　　　　 返回set容器的最后一个元素地址  clear()   　　     删除set容器中的所有的元素  empty() 　　　 判断set容器是否为空  max_size() 　   返回set容器可能包含的元素最大个数  size() 　　　　 返回当前set容器中的元素个数  erase(it) 　　　　 删除迭代器指针it处元素  find() 　　　　 查找元素出现的位置, 如果出现返回迭代器, 如果不出现返回set.end();  使用代码示例1:    #include &lt;iostream&gt; #include &lt;set&gt;  using namespace std;  int main() {     set &lt;int&gt; s;     for( int i = 10; i &gt;= 0; --i ) {         s.insert(i);     }     for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) {         cout &lt;&lt; *it &lt;&lt; endl;     }     cout &lt;&lt; "size = " &lt;&lt; s.size() &lt;&lt; endl;     s.clear();     cout &lt;&lt; "size = " &lt;&lt; s.size() &lt;&lt; endl;      if(s.empty()) {         cout &lt;&lt; "now the set is empty!\n";     }     for( int i = 10; i &gt;= 0; --i ) {         s.insert(i);     }     set&lt;int&gt;::iterator ii = s.begin();     s.erase(ii);     for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) {         cout &lt;&lt; *it &lt;&lt; endl;     } }  我在查资料的时候看到有博主提到count函数  这是算法库中的计数函数, 返回一个值在容器中出现的次数  包含在algorithm中  count(begin, end, value);  以及count_if函数, 自定义计数规则  示例2:    #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #define random(a,b) rand()%(b+1-a) + a  using namespace std;  bool cmp(int n) {     if(n &gt; 10) return 1;     else return 0; }  int main() {     srand(time(NULL));     int a[100];     for( int i = 0; i &lt; 100; ++i ) {         a[i] = random(1, 20);          cout &lt;&lt; a[i] &lt;&lt; ' ';     }     cout &lt;&lt; endl;     cout &lt;&lt; count_if(a, a+100, cmp); }  使用示例3:    #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt;  using namespace std;  int main() {     set&lt;int&gt;s;     for( int i = 0; i &lt; 20; ++i ) {         s.insert(i%6);     }     cout &lt;&lt; "size = " &lt;&lt; s.size() &lt;&lt; endl;     set&lt;int&gt;::iterator it = s.begin();     while(it != s.end()) {         cout &lt;&lt; *it &lt;&lt; endl;         it++;     }     cout &lt;&lt; *s.find(4) &lt;&lt; endl;     if(s.find(6) == s.end()) {         cout &lt;&lt; "no such a number !\n";     }     cout &lt;&lt; count(s.begin(), s.end(), 2) &lt;&lt; endl;     cout &lt;&lt; count(s.begin(), s.end(), -1) &lt;&lt; endl;     cout &lt;&lt; count(s.begin(), s.end(), 6) &lt;&lt; endl; }  参考资料1  参考资料2  参考资料3                                            