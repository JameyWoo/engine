                                                                                                                                                         &lt;&lt;算法竞赛入门经典-训练指南&gt;&gt;第一道题目.  被这本书吓到了, 以为都是难题. 这道题不难, 思路是贪心.  时间复杂度也只有O(n)  第一个版本核心部分虽然是二重循环嵌套, 但私以为有if控制条件, 实际上计算量是O(n)的.    #include &lt;bits/stdc++.h&gt; using namespace std;  void loop(int n, int m) {     int *a = new int [n], *b = new int [m];     for(int i = 0; i &lt; n; ++i)          cin &gt;&gt; a[i];     for(int j = 0; j &lt; m; ++j)         cin &gt;&gt; b[j];     sort(a, a + n);     sort(b, b + m);     int ans = 0, flag = 0;     bool f = 0;     for(int i = 0; i &lt; n; ++i) {         f = 0;         for(int j = flag; j &lt; m; ++j) {             if(b[j] &gt;= a[i]) {                 f = 1;                 flag = j + 1;                 ans += b[j];                 break;             }         }     }     if(!f) cout &lt;&lt; "Loowater is doomed!\n";     else cout &lt;&lt; ans &lt;&lt; endl; }  int main() {     int n, m;     while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n != 0) {         loop(n, m);     } }  /* 2 3 5 4 7 8 4 2 1 5 5 10 0 0 */  第二版本是借鉴了书上的, 时间复杂度只有O(m).  这种思维或是解题方法算是很巧妙了.  两数组都排下序, 然后从小到大相互比较. 同时根据条件移动.    #include &lt;bits/stdc++.h&gt; using namespace std;  void loop(int n, int m) {     int *a = new int [n], *b = new int [m];     for(int i = 0; i &lt; n; ++i)          cin &gt;&gt; a[i];     for(int j = 0; j &lt; m; ++j)         cin &gt;&gt; b[j];     sort(a, a + n);     sort(b, b + m);     int cnt = 0, ans = 0, flag = 0;     for(int i = 0; i &lt; m; ++i) {         if(b[i] &gt;= a[cnt++]) {             ans += b[i];             if(cnt == n) {                 flag = 1;                 break;             }         }        }     if(flag) cout &lt;&lt; ans &lt;&lt; endl;     else cout &lt;&lt; "Loowater is doomed!\n"; }  int main() {     int n, m;     while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n != 0) {         loop(n, m);     } }  /* 2 3 5 4 7 8 4 2 1 5 5 10 0 0 */                                            