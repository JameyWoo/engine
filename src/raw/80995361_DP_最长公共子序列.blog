                                                                                                                                                         最长公共子序列也是简单的DP问题, 问题描述是: 对两个字符串, 求他们的最长公共子序列的长度, 所谓公共子序列可以不连续.     如”sadstory” 和 “adminsorry”, 所长公共子序列为adsory. 长度为6   分析这道题, 用到经典的二维DP思想, 把大问题化解为子问题.   对S1的每个i,长度序列 和S2的每个j长度序列, 最优解是多少, 大问题的最优解就是基于子问题的最优解.     考量这两种情况:    1. S1[i] = S2[j], 那么dp[i][j] = dp[i-1][j-1] + 1    2.  S1[i] != S2[j], 那么dp[i][j] = max(dp[i-1][j], dp[i][j-1]).   问题就是这么简单, 理解了状态转移, 就是理解了这个问题.  #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std;  int main() {     string s1, s2;     int dp[105][105];     memset(dp, 0, sizeof(dp));     cin &gt;&gt; s1 &gt;&gt; s2;     for (int i = 0; i &lt; (int)s1.size(); ++i) {         if (s2[0] == s1[i]) dp[i][0] = 1;         if (s1[0] == s2[i]) dp[0][i] = 1;     }     for (int i = 1; i &lt; int(s1.size()); ++i) {         for (int j = 1; j &lt; int(s2.size()); ++j) {             if (s1[i] == s2[j]) dp[i][j] = dp[i - 1][j - 1] + 1;             else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);         }     }     cout &lt;&lt; dp[s1.size() - 1][s2.size() - 1]; } /* sadstory adminsorry ans = 6 */                                             