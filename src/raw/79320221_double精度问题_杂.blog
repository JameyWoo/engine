                                                                                                                                                         无类型的文件, 直接去掉后缀即可, 如sublime的默认文件类型    时间复杂度为logn无底数  因为:  从理论上，无论底是什么都无关紧要，因为不同底的logn之间只存在常数倍的关系，这与n无关，不会影响复杂度的大小。  因为double这种浮点型的数在计算机中是按照二进制存储的, 而一个double数是64位, 8Byte期中指数位11位, 尾数为52位(二进制)  一个介绍浮点数的连接       类型   符号位   指数位   尾数位      float   1   8   23     double   1   11   52     小数转二进制方法?  整数位按照整数的方法转化, 小数位用乘2法  例如0.6转二进制,文字描述该过程如下：     将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，知道小数部分为0。    特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因   一个博客链接    小数的二进制转十进制呢? 道理和十进制相同  如:     0.101 转 十进制    0.101 = 1*2^-1 + 0*2^-2 + 1*2^-3   给出一段粗糙代码    #include &lt;iostream&gt; #include &lt;string&gt; using namespace std;  int main() {     double d;     int t = 0;     string s = "";     cin &gt;&gt; d;  //输入小于1的小数      while(t &lt;= 16) {         ++t, d *= 2;         if(d &gt;= 1.0) {             s += '1';             d -= 1.0;         } else s += '0';     }     cout &lt;&lt; "0." &lt;&lt; s; }    还有常见的double爆精度问题  因为double二进制存储的原因，计算机只会处理小数位15位， 所以  看下面这个似乎匪夷所思的程序    #include &lt;iostream&gt; using namespace std;  int main() {     double a = 1e300, b = 1e100;     double c = 1e300;     a += b;     if(a == c) {         cout &lt;&lt; "now a is equal c \n";     } }  运行结果是     now a is equal c     hack指的是codeforce比赛中找别人漏洞的“攻击方式”  认为它的代码过不了什么数据， 就拿这个数据hack他  这是百度知道一个关于如何hack的回答     对某一题，首先你自己要先过TEST。然后回到比赛的PROBLEM列表，把这题后面的锁锁上（锁上了就不能再提交了，所以没把握就别锁了），然后到ROOM里面，你就可以看别人代码了，下面有HACK按钮，点一下，输入你觉得他错的样例。     有一种常被我忽略的long double类型， 精度比double更高（废话…)  在c的格式控制中如何使用格式控制呢？  *float 应该使用 %f  *double 应该使用 %lf  *long double 应该使用 %Lf  但double使用%f DevC++也不会警告    #include &lt;iostream&gt; #include &lt;cstdio&gt;  using namespace std;  int main() {     float f = 2.34;     printf("%f\n", f);     double d = 1.23;     printf("%lf\n", d);     long double ld = 3.45;     printf("%Lf\n", ld); }                                            