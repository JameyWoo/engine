                                                                                                                                                         CCF 201512-4 送货 传送门  此题只得了80分, 说是运行错误, 找了好久的bug, 都找不出哪里出错. 然后找了其他博客代码, 提交了三四个, 都是80分(他们博客上说是100分代码).   然后我想, 这应该是CCF的问题吧.  这道题就是求欧拉路径.   注意几点: 1.一定要判断是否是连通图, 不然是错的.(判断输出点数是否为m + 1即可)  2.bool类型可以开boo[10000][10000]的, 大约100M的内存, 但是int不可以(256M限制)  3. 欧拉路径倒着存, 倒着输出. 如果遇到了就push的话, 孤立点会出错   80分代码在我心中它是100分. 哦耶  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std;  const int maxn = 10010; int n, m, degree[maxn] = {}, odd = 0; vector&lt;int&gt; G[maxn], ans; bool Gra[maxn][maxn] = {};  void Euler(int u) {     for (int i = 0; i &lt; G[u].size(); ++i) {         int v = G[u][i];         if (Gra[u][v]) {             Gra[u][v] = Gra[v][u] = false;             Euler(v);         }     }     ans.push_back(u); }  int main() {     cin &gt;&gt; n &gt;&gt; m;     for (int i = 0; i &lt; m; ++i) {         int u, v;         cin &gt;&gt; u &gt;&gt; v;         degree[u]++, degree[v]++;         G[u].push_back(v), G[v].push_back(u);         Gra[u][v] = Gra[v][u] = true;     }     for (int i = 1; i &lt;= n; ++i) {         if (degree[i] % 2 == 1) odd++;     }     if (!(odd == 0 || (odd == 2 &amp;&amp; degree[1] % 2))) {         cout &lt;&lt; -1;         return 0;     }     for (int i = 1; i &lt;= n; ++i) {         sort(G[i].begin(), G[i].end());     }     Euler(1);     if (ans.size() != m + 1) {         cout &lt;&lt; -1;         return 0;     }     for (int i = ans.size() - 1; i &gt;= 0; --i) {         cout &lt;&lt; ans[i] &lt;&lt; ' ';     } }                                            