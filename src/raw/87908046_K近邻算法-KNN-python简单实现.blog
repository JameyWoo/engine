                                                                                                                                                         KNN算法是一种简单的机器学习算法，从大致原理上来理解相对简单。 主要思路就是计算要分类的测试特征向量与训练数据集的特征向量的距离，计算距离的方法可以有很多种（如欧氏距离，海明距离），选取与其距离最小的k个特征向量，然后分析这k个向量所属的类别，其中，数量最多的类别可是做测试数据的类别。因此KNN可用于简单分类。 K值得选择会对K近邻算法的结果产生重大影响。 k近邻法没有显式的学习过程。没有训练算法的过程。  1、优缺点分析  2、一般流程  3、伪代码过程  4、《机器学习实战》源码分析 from numpy import * import numpy as np import operator   # print("hello, world")  def createDataSet():     group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) # 特征向量     labels = ['A', 'A', 'B', 'B'] # 标签     return group, labels  group, labels = createDataSet()   # In[39]:   def classify0(inX, dataSet, labels, k):     dataSetSize = dataSet.shape[0] # 特征向量的数量，4     diffMat = tile(inX, (dataSetSize, 1)) - dataSet # tile方法可以将矩阵以指定的方式扩展，这里用来快速计算差值     sqDiffMat = diffMat ** 2 # 计算差值的平方     sqDistances = sqDiffMat.sum(axis=1) # 平方和的计算     distances = sqDistances ** 0.5 # 开平方，得到距离     sortedDistIndicied = distances.argsort()# 按数值的升序排列返回下标     classCount = {}     for i in range(k):         voteIlabel = labels[sortedDistIndicied[i]]         classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 # 字典的get方法，如果有这个key，则选择它的值，否则选择0，然后+1     sortedClassCount = sorted(classCount.items(), # 给字典排序                               key=operator.itemgetter(1), reverse=True)     return sortedClassCount[0][0]  print(classify0([0.2, 0.5], group, labels, 3))   1、对numpy中的titl方法的分析  2、两种轴的求和方式  3、给字典按值排序的方法                                               