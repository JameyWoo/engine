                                                                                                                                                         这个大整数除法指的是求出 a 除以 b 的整数位结果, 当然余数也可以求, 但不是求精确的小数结果.  举个例子来说思路:  a = 17693   b = 23 求 a / b  len(a) = 5, len(b) = 2  那么  1. 17693 - 23000 &lt; 0, 跳过  2.  17693 - 2300*7 = 1593  3.  1593 - 230*6 = 213  4.  213 - 23*9 = 6  5.  6 - 23 &lt; 0, 跳过  现在很清楚了, 17693 / 23 = 769 余 6  从上面的例子可以很清楚的知道, 其实做除法是一个做减法的过程. 那为什么不直接一次一次减23呢? 因为这样会耗费很多时间, 所以从23的10^len倍减起, 这样时间上会快很多. 当然代码写起来也麻烦不少.    整个代码也不过60+行    #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  vector&lt;int&gt; num1, num2;  void strToVector(string s1, string s2) {     int len1 = s1.size(), len2 = s2.size();     if (len1 &lt; len2) return;     for (int i = len1 - 1; i &gt;= 0; --i) {         num1.push_back(s1[i] - '0');     }     for (int i = len2 - 1; i &gt;= 0; --i) {         num2.push_back(s2[i] - '0');     }     while (num1.size() != num2.size()) num2.insert(num2.begin(), 0); }  bool isBigger(vector&lt;int&gt; v1, vector&lt;int&gt; &amp;v2) // 返回v1是否比v2更大  {     int l1 = v1.size(), l2 = v2.size();     if (l1 != l2) return l1 &gt; l2;     for (int i = l1 - 1; i &gt;= 0; --i) {         if (v1[i] == v2[i]) continue;         if (v1[i] &lt; v2[i]) return 0;         else return 1;     }     return 1; }  void sub(vector&lt;int&gt; &amp;v1, vector&lt;int&gt; v2) // 记得去掉后缀0, .pop_back()  {     while (v2.size() &lt; v1.size()) v2.push_back(0);     for (int i = 0; i &lt; v1.size() + 0; ++i) {         if (v1[i] &lt; v2[i]) {             v1[i] += 10 - v2[i];             v1[i + 1] -= 1;         } else v1[i] -= v2[i];     }     while (v1.back() == 0) {         v1.pop_back();     } }  int main() {     string sn1, sn2;     cin &gt;&gt; sn1 &gt;&gt; sn2;     int len1 = sn1.size(), len2 = sn2.size();     strToVector(sn1, sn2);     int len = len1 - len2, ans = 0;     for (int i = 0; i &lt;= len; ++i) {         int time = 0;         while (isBigger(num1, num2)) {             sub(num1, num2); // 做减法, num1是减后的数             time++;          }         if (isBigger(num1, num2) == isBigger(num2, num1)) time = 1;         ans = ans * 10 + time;         num2.erase(num2.begin()); // 去掉一个零前缀0      }     cout &lt;&lt; ans; } /* 17693 23 */     精确到小数位的高精度除法, 不过似乎对能够整除的情况支持的不是很好. 思路和上面的整数除法是一样的.    #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  bool isBigger(vector&lt;int&gt; a, vector&lt;int&gt; b) {     if (a.size() != b.size()) return a.size() &gt; b.size();     int len = a.size() - 1;     while (len &gt;= 0) {         if (a[len] != b[len]) return a[len] &gt; b[len];         len--;     }     return true; // 当相等时return true  }  void sub(vector&lt;int&gt; &amp;v1, vector&lt;int&gt; v2) // 记得去掉后缀0, .pop_back()  {     while (v2.size() &lt; v1.size()) v2.push_back(0);     for (int i = 0; i &lt; v1.size() + 0; ++i) {         if (v1[i] &lt; v2[i]) {             v1[i] += 10 - v2[i];             v1[i + 1] -= 1;         } else v1[i] -= v2[i];     }     while (v1.back() == 0) {         v1.pop_back();     } }  int main() {     vector&lt;int&gt; a, b;     char c;     string ans = "";     int index = 0, n;      while (1) {         c = getchar();         if (c == ' ' || c == '\n') break;         a.insert(a.begin(), c - '0');     }     while (1) {         c = getchar();         if (c == ' ' || c == '\n') break;         b.insert(b.begin(), c - '0');     }     while (isBigger(a, b)) {         b.insert(b.begin(), 0);         index++;     }     cin &gt;&gt; n;     for (int i = 0; i &lt;= n; ++i) {         int time = 0;         a.insert(a.begin(), 0);         while (isBigger(a, b)) {             sub(a, b);             time++;         }         ans += '0' + time;     }     for (int i = 0; i &lt; ans.size() - 2; ++i) {         if (i == index) {             if (index == 0) cout &lt;&lt; "0";             cout &lt;&lt; '.';         }         cout &lt;&lt; ans[i];     }     if (ans[ans.size() - 1] &gt; '4') cout &lt;&lt; (char)(ans[ans.size() - 2] + 1);     else cout &lt;&lt; ans[ans.size() - 1];     cout &lt;&lt; endl; } /* 213 23 9.2608695652173913043478260869565 */                                            