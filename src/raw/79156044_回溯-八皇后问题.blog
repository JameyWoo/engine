                                                                                                                                                         八皇后问题是经典的回溯问题  常用的方法是递归, 也可以暴力枚举  知乎上有用一行代码写的  我刚接触算法时翻过紫书, 那时了解的知识太少了, 一次翻到八皇后问题, 觉得这好复杂, 怎么做得出来!  于是心里自我暗示地告诉自己这道题很难.  直到今天在计蒜客上看视频时, 提到了八皇后问题, 鉴于视频上内容较基础, 我想是不是八皇后问题其实并不难?  翻书之后, 以我现在的能力还是无法独立思考出, 故看书, 发现理解这个问题并不难, 就是一道常规的回溯问题. 不过对于蒟蒻的我来说, 回溯本身也不是那么简单的.   POJ的八皇后问题:  描述      在国际象棋棋盘上放置八个皇后，要求每两个皇后之间不能直接吃掉对方。  输入      无输入。  输出      按给定顺序和格式输出所有八皇后问题的解（见Sample Output）。  样例输入  样例输出  No. 1 1 0 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 0 0 1 0 0 0  0 0 0 0 0 0 0 1  0 1 0 0 0 0 0 0  0 0 0 1 0 0 0 0  0 0 0 0 0 1 0 0  0 0 1 0 0 0 0 0  No. 2 1 0 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 0 1 0 0 0 0  0 0 0 0 0 1 0 0  0 0 0 0 0 0 0 1  0 1 0 0 0 0 0 0  0 0 0 0 1 0 0 0  0 0 1 0 0 0 0 0  No. 3 1 0 0 0 0 0 0 0  0 0 0 0 0 1 0 0  0 0 0 0 0 0 0 1  0 0 1 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 0 1 0 0 0 0  0 1 0 0 0 0 0 0  0 0 0 0 1 0 0 0  No. 4 1 0 0 0 0 0 0 0  0 0 0 0 1 0 0 0  0 0 0 0 0 0 0 1  0 0 0 0 0 1 0 0  0 0 1 0 0 0 0 0  0 0 0 0 0 0 1 0  0 1 0 0 0 0 0 0  0 0 0 1 0 0 0 0  No. 5 0 0 0 0 0 1 0 0  1 0 0 0 0 0 0 0  0 0 0 0 1 0 0 0  0 1 0 0 0 0 0 0  0 0 0 0 0 0 0 1  0 0 1 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 0 1 0 0 0 0  No. 6 0 0 0 1 0 0 0 0  1 0 0 0 0 0 0 0  0 0 0 0 1 0 0 0  0 0 0 0 0 0 0 1  0 1 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 1 0 0 0 0 0  0 0 0 0 0 1 0 0  No. 7 0 0 0 0 1 0 0 0  1 0 0 0 0 0 0 0  0 0 0 0 0 0 0 1  0 0 0 1 0 0 0 0  0 1 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 1 0 0 0 0 0  0 0 0 0 0 1 0 0  No. 8 0 0 1 0 0 0 0 0  1 0 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 0 0 1 0 0 0  0 0 0 0 0 0 0 1  0 1 0 0 0 0 0 0  0 0 0 1 0 0 0 0  0 0 0 0 0 1 0 0  No. 9 0 0 0 0 1 0 0 0  1 0 0 0 0 0 0 0  0 0 0 1 0 0 0 0  0 0 0 0 0 1 0 0  0 0 0 0 0 0 0 1  0 1 0 0 0 0 0 0  0 0 0 0 0 0 1 0  0 0 1 0 0 0 0 0  ...以下省略   提示      此题可使用函数递归调用的方法求解。  求解出92种放置情况并不难, 理解之后很轻松就可以写出答案, 这道题的坑点是, 做题者要观察输出规则. 对, 它并不是简单的按照回溯顺序输出的.  尝试几种可能之后还是错误, 遂看提示, 才知道输出的结果是行和列转置之后的.  遂修改代码, 把i, j互换, 成功AC.  下面是代码:    #include &lt;iostream&gt; #define N 8  using namespace std;  bool is[N][N] = {}, row[N] = {}, col[N] = {}; bool Left[2*N - 1] = {}, Right[2*N - 1] = {}; int Time = 0;  void print() {     cout &lt;&lt; "No. " &lt;&lt; ++Time &lt;&lt; endl;      for( int i = 0; i &lt; N; ++i ) {         for( int j = 0; j &lt; N; ++j ) {             cout &lt;&lt; (is[j][i] ? 1 : 0) &lt;&lt; ' ';         }         cout &lt;&lt; endl;     } }  void search(int n) {     if( n == N ) {         print();     } else {         for( int i = 0; i &lt; N; ++i ) {             if(row[n] || col[i] || Left[i + n] || Right[n - i + N - 1]) {                 continue;             }             row[n] = col[i] = Left[i + n] = Right[n - i + N -1] = is[n][i] = 1;             search(n + 1);             row[n] = col[i] = Left[i + n] = Right[n - i + N -1] = is[n][i] = 0;         }     } }  int main() {     search(0); }  值得一提的是, 之前我的Left 和Right数组是left 和right, 这样在DEV上编译错误, 说是有二义性. 百度之后想起right 和 left在DEV中可能被包含在了iostream中, 作为控制格式用.  提交之后, POJ上编译错误, 原因是time, 改为Time之后编译成功.  这道题带给我的是一种不正常的输出方式: 转置.   没错, 如果出题人要这样玩我, 我想下次可以解决.  下面是洛谷网的一道八皇后题目的代码:    #include &lt;iostream&gt; //#define N 6 #define YES 1 #define NO 0  using namespace std;  int N, ans = 0, time = 3; bool row[16] = {}, col[16] = {}, dpos[2*16 - 1] = {}, dneg[2*16 - 1] = {}, is[16][16] = {};  void print() {     if(time == 0) return;     time--;     for( int i = 0; i &lt; N; ++i ) {         for( int j = 0; j &lt; N; ++j ) {             if(is[i][j]) cout &lt;&lt; j + 1 &lt;&lt; ' ';         }     }     cout &lt;&lt; endl; }  void search(int n) {     if( n == N ) {         ans++;         print();         return;     } else {         for( int i = 0; i &lt; N; ++i ) {             if(row[n] || col[i] || dpos[n + i] || dneg[n - i + N - 1]) {                 continue;             }             row[n] = col[i] = dpos[n + i] = dneg[n - i + N - 1] = 1;             is[n][i] = 1;             search(n + 1);             is[n][i] = 0;             row[n] = col[i] = dpos[n + i] = dneg[n - i + N - 1] = 0;         }     } }  int main() {     cin &gt;&gt; N;     search(0);     cout &lt;&lt; ans &lt;&lt; endl; }  另一道POJ-2754八皇后题目  代码:    #include &lt;iostream&gt; #define N 8  using namespace std;  bool is[N][N] = {}, row[N] = {}, col[N] = {}; bool Left[2*N - 1] = {}, Right[2*N - 1] = {}; int Time = 0;  void print(int k) {     ++Time;     if( Time == k ) {         for( int i = 0; i &lt; N; ++i ) {             for( int j = 0; j &lt; N; ++j ) {                 if(is[i][j]) cout &lt;&lt; j + 1;             }         }         cout &lt;&lt; endl;     } }  void search(int n, int k) {     if( n == N ) {         print(k);     } else {         for( int i = 0; i &lt; N; ++i ) {             if(row[n] || col[i] || Left[i + n] || Right[n - i + N - 1]) {                 continue;             }             row[n] = col[i] = Left[i + n] = Right[n - i + N -1] = is[n][i] = 1;             search(n + 1, k);             row[n] = col[i] = Left[i + n] = Right[n - i + N -1] = is[n][i] = 0;         }     } }  int main() {     int t, k;     cin &gt;&gt; t;     while( t-- ) {         cin &gt;&gt; k;         search(0, k);         Time = 0;         for( int i = 0; i &lt; N; ++ i ) {             for( int j = 0; j &lt; N; ++j ) {                 is[i][j] = 0;             }             row[i] = col[i] = 0;             Left[2*i] = 0;             Left[2*i + 1] = 0;             Right[2*i] = 0;             Right[2*i + 1] = 0;         }     }  }                                            