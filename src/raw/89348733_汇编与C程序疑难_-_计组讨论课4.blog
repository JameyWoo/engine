                                                                                                                                                         题一  代码一结果是0x80000000，代码二会出现运行错误。 代码一中，在计算变量除以整数时，编译器做了优化，自动将该变量转化成一系列位运算和加法运算。如除以-1，他直接把数据取反了，没有执行除法。而除以变量时，不会执行这样的优化，直接除了。而INT_MIN（有符号）除以-1，和任意整数除以0，一样，会出现错误，这与SIGFPE信号有关。关于SIGFPE信号的wiki。 有以下相关的知识 eflags寄存器 标志位 查看eflags寄存器，他会把标志位为1的位打印出来 i r eflags  SIGFPE 是一个进程在执行了一个错误的算术操作时给他发送的信号。一般有两种情况： 1、整数除以0 2、INT_MIN / -1 在linux命令行中会出现 Floating point exception (core dumped)，也就是浮点数例外 (核心已转储)。  题二  原因如下，截自同学的PPT。   就是说，在老版本GCC中，执行两个如a = f（10）时，第一个会发生精度损失，而第二个不会，所以判断会出现“不等于”。而对于第二个代码，有三个f(10)的计算，所以前两个的结果都存到寄存器当中，发生了相同的精度损失，结果相同，所以判断“等于”。 题三  bug1：申请了内存没有释放 bug2：没有对count的大小进行判断 bug2中如果count很大，如2^30，乘以sizeof(int) = 4 之后，会发生溢出。 malloc的函数原型为 void *malloc(size_t size); 溢出经过强制类型转化后，会变成很小的数，然后没有分配正确的内存。如果不知情使用了这些内存，就会出错。                                              