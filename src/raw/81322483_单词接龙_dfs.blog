                                                                                                                                                         P1019 单词接龙   题目描述 单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast 和 astonishastonish ，如果接成一条龙则变为 beastonishbeastonish ，另外相邻的两部分不能存在包含关系，例如 atat 和 atideatide 间不能相连。  输入输出格式 输入格式：  输入的第一行为一个单独的整数 nn ( n \le 20n≤20 )表示单词数，以下 nn 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.   输出格式：  只需输出以此字母开头的最长的“龙”的长度   输入输出样例 输入样例#1：   5  at  touch  cheat  choose  tact  a  输出样例#1：   23   一道比较中规中矩的dfs吧. 数据有点小, 不然像我这样子暴力求前缀后缀什么的太慢了.  总的来说思路就是统计各个单词之间是否有前后缀关系, 如果有, 那么求出最短的重复序列长度, 如果没有, 设为0. 重点是建立这样的一个数组.  那么我们就可以根据这个进行dfs求结果了, 一个visit数组, 经典的dfs前+1, dfs后-1恢复状态.  关键是要理解题意, 比如说它每个字母最多可以出现两次.  #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  const int INF = 0x3f3f3f3f; int visit[22] = {}, ans = 0, n; vector&lt;vector&lt;int&gt; &gt; les(22, vector&lt;int&gt;(22)); vector&lt;string&gt; str(22);  int get(vector&lt;string&gt; str, int x, int y) {     int ans = 0;     for (int j = str[x].size() - 1; j &gt;= 1; --j) {         bool flag = true;         for (int i = j; i &lt; str[x].size(); ++i) {             if (str[x].size() - j == str[y].size()) {                 flag = false;                 break;             }             if (str[x][i] != str[y][i - j]) {                 flag = false;                 break;             }         }         if (flag) {             ans = str[x].size() - j;             break;         }     }     return ans; }  void dfs(int k, int cnt) {     for (int i = 0; i &lt; n; ++i) {         if (les[k][i] != 0 &amp;&amp; visit[i] &lt;= 1) {             visit[i]++;             dfs(i, cnt + str[i].size() - les[k][i]);             visit[i]--;         }     }     ans = max(ans, cnt); }  int main() {     cin &gt;&gt; n;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; str[i];     }     char ch;     cin &gt;&gt; ch;     for (int i = 0; i &lt; n; ++i) {         for (int j = 0; j &lt; n; ++j) {             les[i][j] = get(str, i, j);         }     }     for (int i = 0; i &lt; n; ++i) {         if (str[i][0] == ch &amp;&amp; str[i].size() != 1) {             visit[i]++;             dfs(i, str[i].size());             visit[i]--;         }     }     cout &lt;&lt; ans; } /* 5 at touch cheat choose tact a */                                            