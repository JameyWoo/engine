                                                                                                                                                            一个正整数，如果交换高低位以后和原数相等，那么称这个数为回文数。比如 121121，23322332    都是回文数，13,456713,4567 不是回文数。      任意一个正整数，如果其不是回文数，将该数交换高低位以后和原数相加得到一个新的数，如果新数不是回文数，重复这个变换，直到得到一个回文数为止。例如，5757    变换后得到 132(57 + 75)132(57+75)，132132 得到 363(132 +    231)363(132+231)，363363 是一个回文数。      曾经有数学家猜想：对于任意正整数，经过有限次上述变换以后，一定能得出一个回文数。至今这个猜想还没有被证明是对的。现在请你通过程序来验证。      输入格式 输入一行一个正整数 nn。      输出格式 输出第一行一个正整数，表示得到一个回文数的最少变换次数。      接下来一行，输出变换过程，相邻的数之间用”—&gt;”连接。输出格式可以参见样例。      保证最后生成的数在 int 范围内。      349     样例输出     3    简单的模拟一下就好。不过， 计蒜客的官方思路有点意思。  官方思路：    #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  int fz(int n) {     int x = 0;     while(n) {         x = x*10 + n%10;         n /= 10;     }     return x; }  int main() {     int n, cur = 0, tmp;     cin &gt;&gt; n;     cur = fz(n);     tmp = n;     vector &lt;int&gt; v;     while(n != cur) {         n += cur;         v.push_back(n);         cur = fz(n);     }     cout &lt;&lt; v.size() &lt;&lt; endl;     cout &lt;&lt; tmp;     for(int i = 0; i &lt; v.size(); ++i) {         cout &lt;&lt; "---&gt;" &lt;&lt; v[i];     } }  我的思路：    #include &lt;iostream&gt; using namespace std;  bool isH(int &amp;n) {     int a = n, b = 0;     while(a) {         b = b*10 + a%10;         a /= 10;     }     if(b == n) return 1;     else {         n += b;         return 0;     } }  int main() {     int n, cnt = 0, tmp;     cin &gt;&gt; n;     tmp = n;     while(1) {         if(isH(n)) {             break;         } else {             cnt ++;         }     }     cout &lt;&lt; cnt &lt;&lt; endl;     n = tmp;     cout &lt;&lt; n;     while(1) {         if(isH(n)) {             break;         } else {             cnt ++;             cout &lt;&lt; "---&gt;" &lt;&lt; n;         }     } }  其实都差不多， 就是为了水个题解（。。。）                                            