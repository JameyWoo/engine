                                                                                                                                                         　　我今天晚上复习Ｃ＋＋类的用法，在使用友元重载双目运算符＋的时候，出现了一个诡异的错误．百思不得其解，专门重写一个类进行测试，最后发现了原因.猛然想起我之前也犯过这样的错误,以为经典,故记之．  　　奉上错误代码：  #include &lt;iostream&gt; using namespace std;  class Complex { //一个复数类      public:         Complex () {} //无参构造          Complex (int a, int b) { //有参构造              real = a;             imag = b;         }         friend Complex operator + (int &amp;, Complex &amp;); //友元重载+       private:         int real, imag; };  Complex operator + (int &amp;a, Complex &amp;c) //友元重载+  {     return Complex (a+c.real, c.imag); }  int main( ) {      Complex c(1, 2);     Complex d = 1 + c; //使用重载+函数  }  　　这是一个简单的Ｃｏｍｐｌｅｘ复数类，除构造函数外只有一个友元重载＋函数．这个函数有个错误．  报错是这样的:      [Error] no match for ‘operator+’ (operand types are ‘int’ and ‘Complex’)      大意是没有”operator+”这个函数.我觉得很奇怪,怎么会没有呢?我这里明明写了呀.一番纠结,挣扎,终于发现右边提示的类型:int, Complex.猛然想起此前犯过这样的错误.      如何?这里不能用引用!      也就是说,函数的形参类型应该是int而非int &amp;,因为,对int型变量n来说:    Complex c(1, 2);     //Complex d = 1 + c; //使用重载+函数     int n = 1;     Complex d = n + c; //正确  是正确的,n可以引用,因为它是一个变量,有地址.它传递过去的类型可以是int, 也可以是int &amp;.  而前面的呢?常数1是没有地址的,所以它传递过去的类型只能是int, 而不能是int &amp;.常数是没有地址的.同const型常量.  所以,这个”诡异”的错误就这样解决了.  然而,从这个错误中,我们能学到什么?  首先:我在变量这一块的基础知识并不扎实, 在更早之前(第一次出现这样的错误之前), 我并没有多深刻地理解int与int &amp;的区别.这让我回想起了此前我出现过好几次同样”诡异”的错误,那就是:  double a; int b, c; b = 1; c = 3; a = b/c;  类似于这种形式的不同类型变量之间的运算. 此式的结果是a = 0, 因为右边是两个int型变量计算, 还未涉及到double, 该消的不该消的它都消了. 这个小小的错误曾让我卡在一道题目上一个多小时.  其次:在这个重载函数中我为什么要用int &amp;呢?为什么不直接用int ?大概是我印象中有过类似在类中某些函数一般是用引用, 而在这个函数中潜意识的收到影响了.值得反思的是:我写这么一个非常规类型是,并没有明确思考我为什么要这样写. 而是稀里糊涂, 脑子里有一点印象就写上了, 结果犯了这么一个错误.不过这是好事, 遇见错误是好事, 倘若我从一开始就直接使用int, 那我就不会和这错误在次相遇. 塞翁失马-焉知非福.                                            