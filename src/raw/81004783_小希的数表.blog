                                                                                                                                                            【问题描述】      Gardon 昨天给小希布置了一道作业，即根据一张由不超过 5000 的 N(3&lt;=N&lt;=100)个正整数组成的数表两两相加得到    N*(N-1)/2 个和，然后再将它们排序。例如，如果数表里含有四个数 1，3，4，9，那么正确答案是    4，5，7，10，12，13。小希做完作业以后出去玩了一阵，可是下午回家时发现原来的那张数表不见了，好在她做出的答案还在，你能帮助她根据她的答案计算出原来的数表么？      【输入形式】      包含多组数据，每组数据以一个 N 开头，接下来的一行有按照大小顺序排列的 N*(N-1)/2 个数，是小希完成的答案。文件最后以一个 0    结束。 假设输入保证解的存在性和唯一性。      【输出形式】      对于每组数据，输出原来的数表。它们也应当是按照顺序排列的。      【样例输入】      4 4 5 7 10 12 13 4 5 6 7 8 9 10 0 【样例输出】      1 3 4 9 2 3 4 6   暑假变成训练里的一道题, 我觉得它是道很好的题, 所以写一篇博客.   已知n个数两两之和, 如何逆推求出所有的n个数?  1. 观察一下可以发现, 如果a1 - an是递增的n个数, 那么他们的和s1, s2, s3…(也是递增), s1 = a1 + a2, s2 = a1 + a3, 那么只要找出a2 + a3, 就可以求出a1了  2.  如何找出a2 + a3呢, 显然它不是s3. 但是我们可以遍历s3直到s(n*(n+1)/2), 假设这个s是a2 + a3, 从而求解出a1  3.  OK, 那么假设我们已经求出了a1, 有什么用? 我们可以求出a2, 因为s1是a1和a2的和, 我们在所有和中剔除已知数两两之和(a1, a2), 剩下的最小s就是a1+a3, 那么可求出a3, 再利用a3将可以求出的s剔除掉, 剩下的s的最小就是a1+a4, 同理, 利用这个规则可以求解出所有的a  遇到了不可满足的情况, 就换一个a2+a3, 找到了第一个就可以退出了, 因为题目给出的数据是唯一的而且有解的    // 这道题的错误就是vis数组没有在每个循环都初始化! 导致前面的数据残留影响结果, 思路是正确的  #include &lt;iostream&gt; using namespace std; const int maxn = 105;  int main() {     int n;     while (cin &gt;&gt; n &amp;&amp; n) {         int sum[n * (n - 1) / 2], all = n * (n - 1) / 2;         //cout &lt;&lt; n &lt;&lt; endl;         for (int i = 0; i &lt; all; ++i) {             cin &gt;&gt; sum[i];             //cout &lt;&lt; sum[i] &lt;&lt; ' ';         }         for (int k = 2; k &lt; all; ++k) { // 从s2开始遍历, 找到一种可能的情况就结束              int num[n + 5] = {};             bool vis[all] = {}; // 草, 这个声明要在循环里面, 或者每次循环清空!!!              if ((sum[0] + sum[1] - sum[k]) % 2 || (sum[0] + sum[1] - sum[k] &lt;= 0))                  continue; // 奇数当然不可能滴              num[0] = (sum[0] + sum[1] - sum[k]) / 2;             num[1] = (sum[0] - num[0]);             num[2] = (sum[1] - num[0]);             vis[0] = vis[1] = vis[k] = 1;             //cout &lt;&lt; "a1 = " &lt;&lt; num[0] &lt;&lt; "  a2 = " &lt;&lt; num[1] &lt;&lt; "  a3 = " &lt;&lt; num[2] &lt;&lt; endl;             int know = 2;             bool flag = 1;              while (know != n - 1) { // 直到所有的数都已知                 int in = -1;                 for (int i = 0; i &lt; all; ++i) {                     if (vis[i] == 0) {                         in = sum[i]; // 找到剩下的和的最小值                          //cout &lt;&lt; "in = " &lt;&lt; in &lt;&lt; endl;                         vis[i] = 1;                         break;                     }                 }                 num[++know] = in - num[0];                 //cout &lt;&lt; "第" &lt;&lt; know &lt;&lt; "个是 " &lt;&lt; num[know] &lt;&lt; endl;                  for (int i = 1; i &lt; know; ++i) {                     int he = num[know] + num[i]; // 可以组成的和, 接下来就是除去他们,如果找不到,就退出                      flag = 0;                     //cout &lt;&lt; " he = " &lt;&lt; he &lt;&lt; "  num[know] = " &lt;&lt; num[know] &lt;&lt; endl;                     for (int j = 0; j &lt; all; ++j) {                         if (vis[j] == 0 &amp;&amp; sum[j] == he) {                             vis[j] = 1;                             flag = 1;                             break;                         }                     }                     if (flag == 0) break;                 }                 if (flag == 0) break;             }             //cout &lt;&lt; "know = " &lt;&lt; know &lt;&lt; endl;             if (know != n - 1) continue;             for (int i = 0; i &lt; n; ++i) {                 cout &lt;&lt; num[i] &lt;&lt; ' ';             }             cout &lt;&lt; endl;             break;         }     } } /* 【样例输入】  4 4 5 7 10 12 13 4 5 6 7 8 9 10 0 【样例输出】  1 3 4 9 2 3 4 6  3 4 6 8 */   总之这道题挺有意思的, 一个看似无法解决的问题, 在计算机的高速计算性能下, 也是可以解决的.   得出一个道理: 有时候我们会觉得难以解决的问题, 可能不是思维上的问题(没有方法), 可能只是数据很大, 我们思维定势觉得我们无法解决这样的问题, 然而其实可以通过计算机, 利用这种计算思维, 将求解过程模拟出来.                                             