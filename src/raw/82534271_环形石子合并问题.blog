                                                                                                                                                         环形石子合并问题是在普通的相邻石子合并问题的基础上稍加拓展，石子变成了环形的，也就是说每个石子都可能和其左右两边的石子合并。  那么它的dp解法也是基于普通的相邻石子合并问题，不了解的同学可以参考我写过的这篇文章。  有两种解法，但他们基本的算法思想是一样的。    第一种是和上面链接文章的写法类似，不同的是对于需要绕圈的点，普通的相邻石子合并问题是直接跳过（因为它无法到达），而对于环形的，有两种实现方法。  其一：使用一个取模运算，实现环形dp。其二：将环形拓展成2倍链状，开二倍的数组即可实现，这个比较好理解好实现。    #include &lt;iostream&gt; using namespace std;  int n, num[105], sum[105] = {}; int dp[105][105], ans = 0x3f3f3f3f;;  int main() {     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         cin &gt;&gt; num[i];         num[i + n] = num[i];         dp[i][i] = 0;     }     for (int i = 1; i &lt;= n + n; ++i) {         sum[i] = sum[i - 1] + num[i];     }     for (int k = 2; k &lt;= n; ++k) {         for (int i = 1; i &lt;= 2*n - k + 1; ++i) {             int j = i + k - 1;             dp[i][j] = 0x3f3f3f3f;             for (int t = i; t &lt; j; ++t) {                 dp[i][j] = min(dp[i][j], dp[i][t] + dp[t + 1][j] + sum[j] - sum[i - 1]);             }         }     }     for (int i = 1; i &lt;= n; ++i) {         ans = min(ans, dp[i][i + n - 1]);     }     cout &lt;&lt; ans; } /* 3 1 2 3  6 3 5 7 3 4 2  4 3 5 2 3  9 1264 324 2344 23242 435 342 3243 6787 244 // 76328 */    第二种解法和上面不同的是dp[n][m]数组。它的含义是：从石头n开始的长度m的区间的dp结果。而上面的dp[n][m]数组的含义是：从石头n到石头m这个闭区间的dp结果。  开这样一个数组效果和第一种是一样的，但对于我来说在思维上算是一种扩展。  #include &lt;iostream&gt; using namespace std;  int sum[100] = {0}, ans = 0x3f3f3f3f; int n, num[100], dp[100][100];  int getsum(int u, int s) {     s--;     if (u + s &gt; n) return sum[n] - sum[u - 1] + sum[(u + s)%n];     else return sum[u + s] - sum[u - 1]; }  int main() {     cin &gt;&gt; n;     for (int i = 1; i &lt;= n; ++i) {         cin &gt;&gt; num[i];         sum[i] = sum[i - 1] + num[i];         dp[i][1] = 0;     }     for (int k = 2; k &lt;= n; ++k) {         for (int i = 1; i &lt;= n; ++i) {             dp[i][k] = 0x3f3f3f3f;             for (int t = 1; t &lt; k; ++t) {                 dp[i][k] = min(dp[i][k], dp[i][t] + dp[(i + t - 1) % n + 1][k - t] + getsum(i, k));             }         }     }     for (int i = 1; i &lt;= n; ++i) {         ans = min(ans, dp[i][n]);     }     cout &lt;&lt; ans; } /* 3 1 2 3  6 3 5 7 3 4 2  4 3 5 2 3  9 1264 324 2344 23242 435 342 3243 6787 244 // 76328 */                                            