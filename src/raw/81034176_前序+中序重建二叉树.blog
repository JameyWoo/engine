                                                                                                                                                         如何构建一棵二叉树?  代码只有自己真正写的时候才会发现很多漏洞. 因为当我写好代码, 以为一切万事大吉的时候, 发现一切根本不是那么回事! 所有的一切都崩塌了!  输入一组数据就可以构建二叉树? too young too simple !   不过我还是那样干了, 按照书上说的插入方法, 每次传递一个数就在二叉树中插入一个数, 就这样构建起了一棵经不起考验的二叉树. 按照插入的规则找到第一个NULL, 把数插入进去, 这显然对于一般的是不行的.  我的理解是, 按照这种方法插入的树是一棵单链的树!!! 因为规则就完全错了.  下面其中操作包括  1. 二叉树结点的建立, 最好声明时就把子结点指向NULL  2.  插入结点. 插入的规则一定要规定好, 要不然乱七八糟.   3.  前序遍历, 中序遍历, 后序遍历. 一个模子.  代码很垃圾, 但是可以作为二叉树操作的模板. 虽然逻辑有问题  /* 似乎是失败了  目的:  1. 二叉树的建立(插入操作) */ #include &lt;iostream&gt; using namespace std;  struct Node {     int val;     Node *left, *right; };  Node* newNode(int x) {     Node* node = new Node;     node-&gt;val = x;     node-&gt;left = node-&gt;right = NULL;  // 这个很重要! 一定不要忘!      return node; }  void insert(Node* &amp;root, int x, bool &amp;flag) // &amp;很重要!  {     if (root == NULL) {         if (flag) {             root = newNode(x);             flag = 0;         }         return;     }     insert(root-&gt;left, x, flag);     insert(root-&gt;right, x, flag); }  // 话说这个建树的过程好奇怪  Node* creatTree(int data[], int n) {     Node* root = NULL;      for (int i = 0; i &lt; n; ++i) {         bool flag = 1;         insert(root, data[i], flag);     }     return root; }  void preOrder(Node* root) {     if (root == NULL) return;     cout &lt;&lt; root-&gt;val &lt;&lt; ' ';     preOrder(root-&gt;left);     preOrder(root-&gt;right); }  void inOrder(Node *root) {     if (root == NULL) return;     inOrder(root-&gt;left);     cout &lt;&lt; root-&gt;val &lt;&lt; ' ';     inOrder(root-&gt;right); }  void postOrder(Node *root) {     if (root == NULL) return;     postOrder(root-&gt;left);     postOrder(root-&gt;right);     cout &lt;&lt; root-&gt;val &lt;&lt; ' '; }  int main() {     int n, data[1005];     cin &gt;&gt; n;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; data[i];     }     Node *root;     root = creatTree(data, n);     //preOrder(root); // 前序遍历     cout &lt;&lt; root-&gt;right;     //cout &lt;&lt; root-&gt;left-&gt;left-&gt;val; } /* 7 1 2 3 4 5 6 7 */    那么我们来正经的讨论讨论, 怎么重建一棵二叉树呢?  有很多种方法, 这里介绍前序+中序方法  看书可以知道, 要重建一棵二叉树, 至少知道这颗二叉树的中序遍历和(前序遍历与后序遍历中的一个).   三种遍历所给的信息各不相同, 但是其实前序和后序遍历所得到的信息是非常类似的.  前序: 第一个数是根节点.  中序: 左子树在根节点左边, 右子树在根节点右边  所以我们可以结合前序和中序的性质, 用前序找到根节点, 在中序中将左子树和右子树划分, 从而递归求解.  注意: 这些函数不要忘记返回root, 不然有啥用?  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  struct Node {     int val;     Node *left, *right; };  Node* newNode(int x) {     Node* root = new Node;     root-&gt;val = x;     root-&gt;left = root-&gt;right = NULL;     return root; // 不要忘了...  }  Node* buildTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) {     if (pre.empty() || vin.empty()) return NULL;      int val = pre[0];     Node *root = newNode(val);     vector&lt;int&gt; preLeft, preRight, vinLeft, vinRight;     int index = -1;     for (index = 0; vin[index] != val; ++index) {         vinLeft.push_back(vin[index]);         preLeft.push_back(pre[index + 1]);     }     for (int i = index + 1; i &lt; vin.size(); ++i) {         vinRight.push_back(vin[i]);         preRight.push_back(pre[i]);     }     root-&gt;left = buildTree(preLeft, vinLeft);     root-&gt;right = buildTree(preRight, vinRight);     return root; // 不要忘记return它了  }  void preOrder(Node* root) {     if (root == NULL) return;     cout &lt;&lt; root-&gt;val &lt;&lt; ' ';     preOrder(root-&gt;left);     preOrder(root-&gt;right); }  int main() {     vector&lt;int&gt; pre, vin;     int n, x;     cin &gt;&gt; n;     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         pre.push_back(x);     }     for (int i = 0; i &lt; n; ++i) {         cin &gt;&gt; x;         vin.push_back(x);     }     Node* root = buildTree(pre, vin);     preOrder(root);     cout &lt;&lt; endl; } /* 8  1 2 4 7 3 5 6 8  4 7 2 1 5 3 8 6 */                                             